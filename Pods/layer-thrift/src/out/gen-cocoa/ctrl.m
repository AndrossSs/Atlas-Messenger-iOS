/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#import <Foundation/Foundation.h>

#import "TProtocol.h"
#import "TApplicationException.h"
#import "TProtocolException.h"
#import "TProtocolUtil.h"
#import "TProcessor.h"
#import "TObjective-C.h"
#import "TBase.h"


#import "ctrl.h"

@implementation LYRTBadRequestException

- (id) init
{
  return [super initWithName: @"BadRequestException" reason: @"unknown" userInfo: nil];
}

- (id) initWithMessage: (NSString *) message
{
  self = [self init];
  __message = [message retain_stub];
  __message_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super initWithCoder: decoder];
  if ([decoder containsValueForKey: @"message"])
  {
    __message = [[decoder decodeObjectForKey: @"message"] retain_stub];
    __message_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  [super encodeWithCoder: encoder];
  if (__message_isset)
  {
    [encoder encodeObject: __message forKey: @"message"];
  }
}

- (void) dealloc
{
  [__message release_stub];
  [super dealloc_stub];
}

- (NSString *) message {
  return [[__message retain_stub] autorelease_stub];
}

- (void) setMessage: (NSString *) message {
  [message retain_stub];
  [__message release_stub];
  __message = message;
  __message_isset = YES;
}

- (BOOL) messageIsSet {
  return __message_isset;
}

- (void) unsetMessage {
  [__message release_stub];
  __message = nil;
  __message_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setMessage: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"BadRequestException"];
  if (__message_isset) {
    if (__message != nil) {
      [outProtocol writeFieldBeginWithName: @"message" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __message];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"BadRequestException("];
  [ms appendString: @"message:"];
  [ms appendFormat: @"\"%@\"", __message];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation LYRTConflictException

- (id) init
{
  return [super initWithName: @"ConflictException" reason: @"unknown" userInfo: nil];
}

- (id) initWithMessage: (NSString *) message
{
  self = [self init];
  __message = [message retain_stub];
  __message_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super initWithCoder: decoder];
  if ([decoder containsValueForKey: @"message"])
  {
    __message = [[decoder decodeObjectForKey: @"message"] retain_stub];
    __message_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  [super encodeWithCoder: encoder];
  if (__message_isset)
  {
    [encoder encodeObject: __message forKey: @"message"];
  }
}

- (void) dealloc
{
  [__message release_stub];
  [super dealloc_stub];
}

- (NSString *) message {
  return [[__message retain_stub] autorelease_stub];
}

- (void) setMessage: (NSString *) message {
  [message retain_stub];
  [__message release_stub];
  __message = message;
  __message_isset = YES;
}

- (BOOL) messageIsSet {
  return __message_isset;
}

- (void) unsetMessage {
  [__message release_stub];
  __message = nil;
  __message_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setMessage: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ConflictException"];
  if (__message_isset) {
    if (__message != nil) {
      [outProtocol writeFieldBeginWithName: @"message" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __message];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ConflictException("];
  [ms appendString: @"message:"];
  [ms appendFormat: @"\"%@\"", __message];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation LYRTUnauthorizedException

- (id) init
{
  return [super initWithName: @"UnauthorizedException" reason: @"unknown" userInfo: nil];
}

- (id) initWithMessage: (NSString *) message nonce: (NSString *) nonce
{
  self = [self init];
  __message = [message retain_stub];
  __message_isset = YES;
  __nonce = [nonce retain_stub];
  __nonce_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super initWithCoder: decoder];
  if ([decoder containsValueForKey: @"message"])
  {
    __message = [[decoder decodeObjectForKey: @"message"] retain_stub];
    __message_isset = YES;
  }
  if ([decoder containsValueForKey: @"nonce"])
  {
    __nonce = [[decoder decodeObjectForKey: @"nonce"] retain_stub];
    __nonce_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  [super encodeWithCoder: encoder];
  if (__message_isset)
  {
    [encoder encodeObject: __message forKey: @"message"];
  }
  if (__nonce_isset)
  {
    [encoder encodeObject: __nonce forKey: @"nonce"];
  }
}

- (void) dealloc
{
  [__message release_stub];
  [__nonce release_stub];
  [super dealloc_stub];
}

- (NSString *) message {
  return [[__message retain_stub] autorelease_stub];
}

- (void) setMessage: (NSString *) message {
  [message retain_stub];
  [__message release_stub];
  __message = message;
  __message_isset = YES;
}

- (BOOL) messageIsSet {
  return __message_isset;
}

- (void) unsetMessage {
  [__message release_stub];
  __message = nil;
  __message_isset = NO;
}

- (NSString *) nonce {
  return [[__nonce retain_stub] autorelease_stub];
}

- (void) setNonce: (NSString *) nonce {
  [nonce retain_stub];
  [__nonce release_stub];
  __nonce = nonce;
  __nonce_isset = YES;
}

- (BOOL) nonceIsSet {
  return __nonce_isset;
}

- (void) unsetNonce {
  [__nonce release_stub];
  __nonce = nil;
  __nonce_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setMessage: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNonce: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UnauthorizedException"];
  if (__message_isset) {
    if (__message != nil) {
      [outProtocol writeFieldBeginWithName: @"message" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __message];
      [outProtocol writeFieldEnd];
    }
  }
  if (__nonce_isset) {
    if (__nonce != nil) {
      [outProtocol writeFieldBeginWithName: @"nonce" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __nonce];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UnauthorizedException("];
  [ms appendString: @"message:"];
  [ms appendFormat: @"\"%@\"", __message];
  [ms appendString: @",nonce:"];
  [ms appendFormat: @"\"%@\"", __nonce];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation LYRTNotFoundException

- (id) init
{
  return [super initWithName: @"NotFoundException" reason: @"unknown" userInfo: nil];
}

- (id) initWithMissingEntity: (NSString *) missingEntity message: (NSString *) message
{
  self = [self init];
  __missingEntity = [missingEntity retain_stub];
  __missingEntity_isset = YES;
  __message = [message retain_stub];
  __message_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super initWithCoder: decoder];
  if ([decoder containsValueForKey: @"missingEntity"])
  {
    __missingEntity = [[decoder decodeObjectForKey: @"missingEntity"] retain_stub];
    __missingEntity_isset = YES;
  }
  if ([decoder containsValueForKey: @"message"])
  {
    __message = [[decoder decodeObjectForKey: @"message"] retain_stub];
    __message_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  [super encodeWithCoder: encoder];
  if (__missingEntity_isset)
  {
    [encoder encodeObject: __missingEntity forKey: @"missingEntity"];
  }
  if (__message_isset)
  {
    [encoder encodeObject: __message forKey: @"message"];
  }
}

- (void) dealloc
{
  [__missingEntity release_stub];
  [__message release_stub];
  [super dealloc_stub];
}

- (NSString *) missingEntity {
  return [[__missingEntity retain_stub] autorelease_stub];
}

- (void) setMissingEntity: (NSString *) missingEntity {
  [missingEntity retain_stub];
  [__missingEntity release_stub];
  __missingEntity = missingEntity;
  __missingEntity_isset = YES;
}

- (BOOL) missingEntityIsSet {
  return __missingEntity_isset;
}

- (void) unsetMissingEntity {
  [__missingEntity release_stub];
  __missingEntity = nil;
  __missingEntity_isset = NO;
}

- (NSString *) message {
  return [[__message retain_stub] autorelease_stub];
}

- (void) setMessage: (NSString *) message {
  [message retain_stub];
  [__message release_stub];
  __message = message;
  __message_isset = YES;
}

- (BOOL) messageIsSet {
  return __message_isset;
}

- (void) unsetMessage {
  [__message release_stub];
  __message = nil;
  __message_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setMissingEntity: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setMessage: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"NotFoundException"];
  if (__missingEntity_isset) {
    if (__missingEntity != nil) {
      [outProtocol writeFieldBeginWithName: @"missingEntity" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __missingEntity];
      [outProtocol writeFieldEnd];
    }
  }
  if (__message_isset) {
    if (__message != nil) {
      [outProtocol writeFieldBeginWithName: @"message" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __message];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"NotFoundException("];
  [ms appendString: @"missingEntity:"];
  [ms appendFormat: @"\"%@\"", __missingEntity];
  [ms appendString: @",message:"];
  [ms appendFormat: @"\"%@\"", __message];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation LYRTInternalException

- (id) init
{
  return [super initWithName: @"InternalException" reason: @"unknown" userInfo: nil];
}

- (id) initWithMessage: (NSString *) message
{
  self = [self init];
  __message = [message retain_stub];
  __message_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super initWithCoder: decoder];
  if ([decoder containsValueForKey: @"message"])
  {
    __message = [[decoder decodeObjectForKey: @"message"] retain_stub];
    __message_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  [super encodeWithCoder: encoder];
  if (__message_isset)
  {
    [encoder encodeObject: __message forKey: @"message"];
  }
}

- (void) dealloc
{
  [__message release_stub];
  [super dealloc_stub];
}

- (NSString *) message {
  return [[__message retain_stub] autorelease_stub];
}

- (void) setMessage: (NSString *) message {
  [message retain_stub];
  [__message release_stub];
  __message = message;
  __message_isset = YES;
}

- (BOOL) messageIsSet {
  return __message_isset;
}

- (void) unsetMessage {
  [__message release_stub];
  __message = nil;
  __message_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setMessage: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"InternalException"];
  if (__message_isset) {
    if (__message != nil) {
      [outProtocol writeFieldBeginWithName: @"message" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __message];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"InternalException("];
  [ms appendString: @"message:"];
  [ms appendFormat: @"\"%@\"", __message];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation LYRTAccount

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
  self.admin = NO;

  self.deleted = NO;

#endif
  return self;
}

- (id) initWithId: (LYRTUUID) id provider_id: (LYRTUUID) provider_id email: (NSString *) email password: (NSString *) password first_name: (NSString *) first_name last_name: (NSString *) last_name company_name: (NSString *) company_name photo_url: (NSString *) photo_url joined: (int64_t) joined first_login: (int64_t) first_login admin: (BOOL) admin deleted: (BOOL) deleted authy_id: (NSString *) authy_id phone: (NSString *) phone phone_cc: (NSString *) phone_cc permissions: (int32_t) permissions
{
  self = [super init];
  __id = [id retain_stub];
  __id_isset = YES;
  __provider_id = [provider_id retain_stub];
  __provider_id_isset = YES;
  __email = [email retain_stub];
  __email_isset = YES;
  __password = [password retain_stub];
  __password_isset = YES;
  __first_name = [first_name retain_stub];
  __first_name_isset = YES;
  __last_name = [last_name retain_stub];
  __last_name_isset = YES;
  __company_name = [company_name retain_stub];
  __company_name_isset = YES;
  __photo_url = [photo_url retain_stub];
  __photo_url_isset = YES;
  __joined = joined;
  __joined_isset = YES;
  __first_login = first_login;
  __first_login_isset = YES;
  __admin = admin;
  __admin_isset = YES;
  __deleted = deleted;
  __deleted_isset = YES;
  __authy_id = [authy_id retain_stub];
  __authy_id_isset = YES;
  __phone = [phone retain_stub];
  __phone_isset = YES;
  __phone_cc = [phone_cc retain_stub];
  __phone_cc_isset = YES;
  __permissions = permissions;
  __permissions_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"id"])
  {
    __id = [[decoder decodeObjectForKey: @"id"] retain_stub];
    __id_isset = YES;
  }
  if ([decoder containsValueForKey: @"provider_id"])
  {
    __provider_id = [[decoder decodeObjectForKey: @"provider_id"] retain_stub];
    __provider_id_isset = YES;
  }
  if ([decoder containsValueForKey: @"email"])
  {
    __email = [[decoder decodeObjectForKey: @"email"] retain_stub];
    __email_isset = YES;
  }
  if ([decoder containsValueForKey: @"password"])
  {
    __password = [[decoder decodeObjectForKey: @"password"] retain_stub];
    __password_isset = YES;
  }
  if ([decoder containsValueForKey: @"first_name"])
  {
    __first_name = [[decoder decodeObjectForKey: @"first_name"] retain_stub];
    __first_name_isset = YES;
  }
  if ([decoder containsValueForKey: @"last_name"])
  {
    __last_name = [[decoder decodeObjectForKey: @"last_name"] retain_stub];
    __last_name_isset = YES;
  }
  if ([decoder containsValueForKey: @"company_name"])
  {
    __company_name = [[decoder decodeObjectForKey: @"company_name"] retain_stub];
    __company_name_isset = YES;
  }
  if ([decoder containsValueForKey: @"photo_url"])
  {
    __photo_url = [[decoder decodeObjectForKey: @"photo_url"] retain_stub];
    __photo_url_isset = YES;
  }
  if ([decoder containsValueForKey: @"joined"])
  {
    __joined = [decoder decodeInt64ForKey: @"joined"];
    __joined_isset = YES;
  }
  if ([decoder containsValueForKey: @"first_login"])
  {
    __first_login = [decoder decodeInt64ForKey: @"first_login"];
    __first_login_isset = YES;
  }
  if ([decoder containsValueForKey: @"admin"])
  {
    __admin = [decoder decodeBoolForKey: @"admin"];
    __admin_isset = YES;
  }
  if ([decoder containsValueForKey: @"deleted"])
  {
    __deleted = [decoder decodeBoolForKey: @"deleted"];
    __deleted_isset = YES;
  }
  if ([decoder containsValueForKey: @"authy_id"])
  {
    __authy_id = [[decoder decodeObjectForKey: @"authy_id"] retain_stub];
    __authy_id_isset = YES;
  }
  if ([decoder containsValueForKey: @"phone"])
  {
    __phone = [[decoder decodeObjectForKey: @"phone"] retain_stub];
    __phone_isset = YES;
  }
  if ([decoder containsValueForKey: @"phone_cc"])
  {
    __phone_cc = [[decoder decodeObjectForKey: @"phone_cc"] retain_stub];
    __phone_cc_isset = YES;
  }
  if ([decoder containsValueForKey: @"permissions"])
  {
    __permissions = [decoder decodeInt32ForKey: @"permissions"];
    __permissions_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__id_isset)
  {
    [encoder encodeObject: __id forKey: @"id"];
  }
  if (__provider_id_isset)
  {
    [encoder encodeObject: __provider_id forKey: @"provider_id"];
  }
  if (__email_isset)
  {
    [encoder encodeObject: __email forKey: @"email"];
  }
  if (__password_isset)
  {
    [encoder encodeObject: __password forKey: @"password"];
  }
  if (__first_name_isset)
  {
    [encoder encodeObject: __first_name forKey: @"first_name"];
  }
  if (__last_name_isset)
  {
    [encoder encodeObject: __last_name forKey: @"last_name"];
  }
  if (__company_name_isset)
  {
    [encoder encodeObject: __company_name forKey: @"company_name"];
  }
  if (__photo_url_isset)
  {
    [encoder encodeObject: __photo_url forKey: @"photo_url"];
  }
  if (__joined_isset)
  {
    [encoder encodeInt64: __joined forKey: @"joined"];
  }
  if (__first_login_isset)
  {
    [encoder encodeInt64: __first_login forKey: @"first_login"];
  }
  if (__admin_isset)
  {
    [encoder encodeBool: __admin forKey: @"admin"];
  }
  if (__deleted_isset)
  {
    [encoder encodeBool: __deleted forKey: @"deleted"];
  }
  if (__authy_id_isset)
  {
    [encoder encodeObject: __authy_id forKey: @"authy_id"];
  }
  if (__phone_isset)
  {
    [encoder encodeObject: __phone forKey: @"phone"];
  }
  if (__phone_cc_isset)
  {
    [encoder encodeObject: __phone_cc forKey: @"phone_cc"];
  }
  if (__permissions_isset)
  {
    [encoder encodeInt32: __permissions forKey: @"permissions"];
  }
}

- (void) dealloc
{
  [__id release_stub];
  [__provider_id release_stub];
  [__email release_stub];
  [__password release_stub];
  [__first_name release_stub];
  [__last_name release_stub];
  [__company_name release_stub];
  [__photo_url release_stub];
  [__authy_id release_stub];
  [__phone release_stub];
  [__phone_cc release_stub];
  [super dealloc_stub];
}

- (NSData *) id {
  return [[__id retain_stub] autorelease_stub];
}

- (void) setId: (NSData *) id {
  [id retain_stub];
  [__id release_stub];
  __id = id;
  __id_isset = YES;
}

- (BOOL) idIsSet {
  return __id_isset;
}

- (void) unsetId {
  [__id release_stub];
  __id = nil;
  __id_isset = NO;
}

- (NSData *) provider_id {
  return [[__provider_id retain_stub] autorelease_stub];
}

- (void) setProvider_id: (NSData *) provider_id {
  [provider_id retain_stub];
  [__provider_id release_stub];
  __provider_id = provider_id;
  __provider_id_isset = YES;
}

- (BOOL) provider_idIsSet {
  return __provider_id_isset;
}

- (void) unsetProvider_id {
  [__provider_id release_stub];
  __provider_id = nil;
  __provider_id_isset = NO;
}

- (NSString *) email {
  return [[__email retain_stub] autorelease_stub];
}

- (void) setEmail: (NSString *) email {
  [email retain_stub];
  [__email release_stub];
  __email = email;
  __email_isset = YES;
}

- (BOOL) emailIsSet {
  return __email_isset;
}

- (void) unsetEmail {
  [__email release_stub];
  __email = nil;
  __email_isset = NO;
}

- (NSString *) password {
  return [[__password retain_stub] autorelease_stub];
}

- (void) setPassword: (NSString *) password {
  [password retain_stub];
  [__password release_stub];
  __password = password;
  __password_isset = YES;
}

- (BOOL) passwordIsSet {
  return __password_isset;
}

- (void) unsetPassword {
  [__password release_stub];
  __password = nil;
  __password_isset = NO;
}

- (NSString *) first_name {
  return [[__first_name retain_stub] autorelease_stub];
}

- (void) setFirst_name: (NSString *) first_name {
  [first_name retain_stub];
  [__first_name release_stub];
  __first_name = first_name;
  __first_name_isset = YES;
}

- (BOOL) first_nameIsSet {
  return __first_name_isset;
}

- (void) unsetFirst_name {
  [__first_name release_stub];
  __first_name = nil;
  __first_name_isset = NO;
}

- (NSString *) last_name {
  return [[__last_name retain_stub] autorelease_stub];
}

- (void) setLast_name: (NSString *) last_name {
  [last_name retain_stub];
  [__last_name release_stub];
  __last_name = last_name;
  __last_name_isset = YES;
}

- (BOOL) last_nameIsSet {
  return __last_name_isset;
}

- (void) unsetLast_name {
  [__last_name release_stub];
  __last_name = nil;
  __last_name_isset = NO;
}

- (NSString *) company_name {
  return [[__company_name retain_stub] autorelease_stub];
}

- (void) setCompany_name: (NSString *) company_name {
  [company_name retain_stub];
  [__company_name release_stub];
  __company_name = company_name;
  __company_name_isset = YES;
}

- (BOOL) company_nameIsSet {
  return __company_name_isset;
}

- (void) unsetCompany_name {
  [__company_name release_stub];
  __company_name = nil;
  __company_name_isset = NO;
}

- (NSString *) photo_url {
  return [[__photo_url retain_stub] autorelease_stub];
}

- (void) setPhoto_url: (NSString *) photo_url {
  [photo_url retain_stub];
  [__photo_url release_stub];
  __photo_url = photo_url;
  __photo_url_isset = YES;
}

- (BOOL) photo_urlIsSet {
  return __photo_url_isset;
}

- (void) unsetPhoto_url {
  [__photo_url release_stub];
  __photo_url = nil;
  __photo_url_isset = NO;
}

- (int64_t) joined {
  return __joined;
}

- (void) setJoined: (int64_t) joined {
  __joined = joined;
  __joined_isset = YES;
}

- (BOOL) joinedIsSet {
  return __joined_isset;
}

- (void) unsetJoined {
  __joined_isset = NO;
}

- (int64_t) first_login {
  return __first_login;
}

- (void) setFirst_login: (int64_t) first_login {
  __first_login = first_login;
  __first_login_isset = YES;
}

- (BOOL) first_loginIsSet {
  return __first_login_isset;
}

- (void) unsetFirst_login {
  __first_login_isset = NO;
}

- (BOOL) admin {
  return __admin;
}

- (void) setAdmin: (BOOL) admin {
  __admin = admin;
  __admin_isset = YES;
}

- (BOOL) adminIsSet {
  return __admin_isset;
}

- (void) unsetAdmin {
  __admin_isset = NO;
}

- (BOOL) deleted {
  return __deleted;
}

- (void) setDeleted: (BOOL) deleted {
  __deleted = deleted;
  __deleted_isset = YES;
}

- (BOOL) deletedIsSet {
  return __deleted_isset;
}

- (void) unsetDeleted {
  __deleted_isset = NO;
}

- (NSString *) authy_id {
  return [[__authy_id retain_stub] autorelease_stub];
}

- (void) setAuthy_id: (NSString *) authy_id {
  [authy_id retain_stub];
  [__authy_id release_stub];
  __authy_id = authy_id;
  __authy_id_isset = YES;
}

- (BOOL) authy_idIsSet {
  return __authy_id_isset;
}

- (void) unsetAuthy_id {
  [__authy_id release_stub];
  __authy_id = nil;
  __authy_id_isset = NO;
}

- (NSString *) phone {
  return [[__phone retain_stub] autorelease_stub];
}

- (void) setPhone: (NSString *) phone {
  [phone retain_stub];
  [__phone release_stub];
  __phone = phone;
  __phone_isset = YES;
}

- (BOOL) phoneIsSet {
  return __phone_isset;
}

- (void) unsetPhone {
  [__phone release_stub];
  __phone = nil;
  __phone_isset = NO;
}

- (NSString *) phone_cc {
  return [[__phone_cc retain_stub] autorelease_stub];
}

- (void) setPhone_cc: (NSString *) phone_cc {
  [phone_cc retain_stub];
  [__phone_cc release_stub];
  __phone_cc = phone_cc;
  __phone_cc_isset = YES;
}

- (BOOL) phone_ccIsSet {
  return __phone_cc_isset;
}

- (void) unsetPhone_cc {
  [__phone_cc release_stub];
  __phone_cc = nil;
  __phone_cc_isset = NO;
}

- (int32_t) permissions {
  return __permissions;
}

- (void) setPermissions: (int32_t) permissions {
  __permissions = permissions;
  __permissions_isset = YES;
}

- (BOOL) permissionsIsSet {
  return __permissions_isset;
}

- (void) unsetPermissions {
  __permissions_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setProvider_id: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setEmail: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setPassword: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setFirst_name: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setLast_name: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 7:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setCompany_name: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 8:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setPhoto_url: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 9:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setJoined: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 10:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setFirst_login: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 11:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setAdmin: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 12:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setDeleted: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 13:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthy_id: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 14:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setPhone: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 15:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setPhone_cc: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 16:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setPermissions: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Account"];
  if (__id_isset) {
    if (__id != nil) {
      [outProtocol writeFieldBeginWithName: @"id" type: TType_STRING fieldID: 1];
      [outProtocol writeBinary: __id];
      [outProtocol writeFieldEnd];
    }
  }
  if (__provider_id_isset) {
    if (__provider_id != nil) {
      [outProtocol writeFieldBeginWithName: @"provider_id" type: TType_STRING fieldID: 2];
      [outProtocol writeBinary: __provider_id];
      [outProtocol writeFieldEnd];
    }
  }
  if (__email_isset) {
    if (__email != nil) {
      [outProtocol writeFieldBeginWithName: @"email" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __email];
      [outProtocol writeFieldEnd];
    }
  }
  if (__password_isset) {
    if (__password != nil) {
      [outProtocol writeFieldBeginWithName: @"password" type: TType_STRING fieldID: 4];
      [outProtocol writeString: __password];
      [outProtocol writeFieldEnd];
    }
  }
  if (__first_name_isset) {
    if (__first_name != nil) {
      [outProtocol writeFieldBeginWithName: @"first_name" type: TType_STRING fieldID: 5];
      [outProtocol writeString: __first_name];
      [outProtocol writeFieldEnd];
    }
  }
  if (__last_name_isset) {
    if (__last_name != nil) {
      [outProtocol writeFieldBeginWithName: @"last_name" type: TType_STRING fieldID: 6];
      [outProtocol writeString: __last_name];
      [outProtocol writeFieldEnd];
    }
  }
  if (__company_name_isset) {
    if (__company_name != nil) {
      [outProtocol writeFieldBeginWithName: @"company_name" type: TType_STRING fieldID: 7];
      [outProtocol writeString: __company_name];
      [outProtocol writeFieldEnd];
    }
  }
  if (__photo_url_isset) {
    if (__photo_url != nil) {
      [outProtocol writeFieldBeginWithName: @"photo_url" type: TType_STRING fieldID: 8];
      [outProtocol writeString: __photo_url];
      [outProtocol writeFieldEnd];
    }
  }
  if (__joined_isset) {
    [outProtocol writeFieldBeginWithName: @"joined" type: TType_I64 fieldID: 9];
    [outProtocol writeI64: __joined];
    [outProtocol writeFieldEnd];
  }
  if (__first_login_isset) {
    [outProtocol writeFieldBeginWithName: @"first_login" type: TType_I64 fieldID: 10];
    [outProtocol writeI64: __first_login];
    [outProtocol writeFieldEnd];
  }
  if (__admin_isset) {
    [outProtocol writeFieldBeginWithName: @"admin" type: TType_BOOL fieldID: 11];
    [outProtocol writeBool: __admin];
    [outProtocol writeFieldEnd];
  }
  if (__deleted_isset) {
    [outProtocol writeFieldBeginWithName: @"deleted" type: TType_BOOL fieldID: 12];
    [outProtocol writeBool: __deleted];
    [outProtocol writeFieldEnd];
  }
  if (__authy_id_isset) {
    if (__authy_id != nil) {
      [outProtocol writeFieldBeginWithName: @"authy_id" type: TType_STRING fieldID: 13];
      [outProtocol writeString: __authy_id];
      [outProtocol writeFieldEnd];
    }
  }
  if (__phone_isset) {
    if (__phone != nil) {
      [outProtocol writeFieldBeginWithName: @"phone" type: TType_STRING fieldID: 14];
      [outProtocol writeString: __phone];
      [outProtocol writeFieldEnd];
    }
  }
  if (__phone_cc_isset) {
    if (__phone_cc != nil) {
      [outProtocol writeFieldBeginWithName: @"phone_cc" type: TType_STRING fieldID: 15];
      [outProtocol writeString: __phone_cc];
      [outProtocol writeFieldEnd];
    }
  }
  if (__permissions_isset) {
    [outProtocol writeFieldBeginWithName: @"permissions" type: TType_I32 fieldID: 16];
    [outProtocol writeI32: __permissions];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Account("];
  [ms appendString: @"id:"];
  [ms appendFormat: @"\"%@\"", __id];
  [ms appendString: @",provider_id:"];
  [ms appendFormat: @"\"%@\"", __provider_id];
  [ms appendString: @",email:"];
  [ms appendFormat: @"\"%@\"", __email];
  [ms appendString: @",password:"];
  [ms appendFormat: @"\"%@\"", __password];
  [ms appendString: @",first_name:"];
  [ms appendFormat: @"\"%@\"", __first_name];
  [ms appendString: @",last_name:"];
  [ms appendFormat: @"\"%@\"", __last_name];
  [ms appendString: @",company_name:"];
  [ms appendFormat: @"\"%@\"", __company_name];
  [ms appendString: @",photo_url:"];
  [ms appendFormat: @"\"%@\"", __photo_url];
  [ms appendString: @",joined:"];
  [ms appendFormat: @"%qi", __joined];
  [ms appendString: @",first_login:"];
  [ms appendFormat: @"%qi", __first_login];
  [ms appendString: @",admin:"];
  [ms appendFormat: @"%i", __admin];
  [ms appendString: @",deleted:"];
  [ms appendFormat: @"%i", __deleted];
  [ms appendString: @",authy_id:"];
  [ms appendFormat: @"\"%@\"", __authy_id];
  [ms appendString: @",phone:"];
  [ms appendFormat: @"\"%@\"", __phone];
  [ms appendString: @",phone_cc:"];
  [ms appendFormat: @"\"%@\"", __phone_cc];
  [ms appendString: @",permissions:"];
  [ms appendFormat: @"%i", __permissions];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation LYRTApnsCert

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
  self.sandbox = YES;

#endif
  return self;
}

- (id) initWithCert: (NSString *) cert password: (NSString *) password sandbox: (BOOL) sandbox
{
  self = [super init];
  __cert = [cert retain_stub];
  __cert_isset = YES;
  __password = [password retain_stub];
  __password_isset = YES;
  __sandbox = sandbox;
  __sandbox_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"cert"])
  {
    __cert = [[decoder decodeObjectForKey: @"cert"] retain_stub];
    __cert_isset = YES;
  }
  if ([decoder containsValueForKey: @"password"])
  {
    __password = [[decoder decodeObjectForKey: @"password"] retain_stub];
    __password_isset = YES;
  }
  if ([decoder containsValueForKey: @"sandbox"])
  {
    __sandbox = [decoder decodeBoolForKey: @"sandbox"];
    __sandbox_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__cert_isset)
  {
    [encoder encodeObject: __cert forKey: @"cert"];
  }
  if (__password_isset)
  {
    [encoder encodeObject: __password forKey: @"password"];
  }
  if (__sandbox_isset)
  {
    [encoder encodeBool: __sandbox forKey: @"sandbox"];
  }
}

- (void) dealloc
{
  [__cert release_stub];
  [__password release_stub];
  [super dealloc_stub];
}

- (NSString *) cert {
  return [[__cert retain_stub] autorelease_stub];
}

- (void) setCert: (NSString *) cert {
  [cert retain_stub];
  [__cert release_stub];
  __cert = cert;
  __cert_isset = YES;
}

- (BOOL) certIsSet {
  return __cert_isset;
}

- (void) unsetCert {
  [__cert release_stub];
  __cert = nil;
  __cert_isset = NO;
}

- (NSString *) password {
  return [[__password retain_stub] autorelease_stub];
}

- (void) setPassword: (NSString *) password {
  [password retain_stub];
  [__password release_stub];
  __password = password;
  __password_isset = YES;
}

- (BOOL) passwordIsSet {
  return __password_isset;
}

- (void) unsetPassword {
  [__password release_stub];
  __password = nil;
  __password_isset = NO;
}

- (BOOL) sandbox {
  return __sandbox;
}

- (void) setSandbox: (BOOL) sandbox {
  __sandbox = sandbox;
  __sandbox_isset = YES;
}

- (BOOL) sandboxIsSet {
  return __sandbox_isset;
}

- (void) unsetSandbox {
  __sandbox_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setCert: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setPassword: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setSandbox: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ApnsCert"];
  if (__cert_isset) {
    if (__cert != nil) {
      [outProtocol writeFieldBeginWithName: @"cert" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __cert];
      [outProtocol writeFieldEnd];
    }
  }
  if (__password_isset) {
    if (__password != nil) {
      [outProtocol writeFieldBeginWithName: @"password" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __password];
      [outProtocol writeFieldEnd];
    }
  }
  if (__sandbox_isset) {
    [outProtocol writeFieldBeginWithName: @"sandbox" type: TType_BOOL fieldID: 3];
    [outProtocol writeBool: __sandbox];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ApnsCert("];
  [ms appendString: @"cert:"];
  [ms appendFormat: @"\"%@\"", __cert];
  [ms appendString: @",password:"];
  [ms appendFormat: @"\"%@\"", __password];
  [ms appendString: @",sandbox:"];
  [ms appendFormat: @"%i", __sandbox];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation LYRTApp

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
  self.enabled = YES;

  self.deleted = NO;

#endif
  return self;
}

- (id) initWithId: (LYRTUUID) id name: (NSString *) name photo_url: (NSString *) photo_url enabled: (BOOL) enabled apns_cert: (LYRTApnsCert *) apns_cert deleted: (BOOL) deleted
{
  self = [super init];
  __id = [id retain_stub];
  __id_isset = YES;
  __name = [name retain_stub];
  __name_isset = YES;
  __photo_url = [photo_url retain_stub];
  __photo_url_isset = YES;
  __enabled = enabled;
  __enabled_isset = YES;
  __apns_cert = [apns_cert retain_stub];
  __apns_cert_isset = YES;
  __deleted = deleted;
  __deleted_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"id"])
  {
    __id = [[decoder decodeObjectForKey: @"id"] retain_stub];
    __id_isset = YES;
  }
  if ([decoder containsValueForKey: @"name"])
  {
    __name = [[decoder decodeObjectForKey: @"name"] retain_stub];
    __name_isset = YES;
  }
  if ([decoder containsValueForKey: @"photo_url"])
  {
    __photo_url = [[decoder decodeObjectForKey: @"photo_url"] retain_stub];
    __photo_url_isset = YES;
  }
  if ([decoder containsValueForKey: @"enabled"])
  {
    __enabled = [decoder decodeBoolForKey: @"enabled"];
    __enabled_isset = YES;
  }
  if ([decoder containsValueForKey: @"apns_cert"])
  {
    __apns_cert = [[decoder decodeObjectForKey: @"apns_cert"] retain_stub];
    __apns_cert_isset = YES;
  }
  if ([decoder containsValueForKey: @"deleted"])
  {
    __deleted = [decoder decodeBoolForKey: @"deleted"];
    __deleted_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__id_isset)
  {
    [encoder encodeObject: __id forKey: @"id"];
  }
  if (__name_isset)
  {
    [encoder encodeObject: __name forKey: @"name"];
  }
  if (__photo_url_isset)
  {
    [encoder encodeObject: __photo_url forKey: @"photo_url"];
  }
  if (__enabled_isset)
  {
    [encoder encodeBool: __enabled forKey: @"enabled"];
  }
  if (__apns_cert_isset)
  {
    [encoder encodeObject: __apns_cert forKey: @"apns_cert"];
  }
  if (__deleted_isset)
  {
    [encoder encodeBool: __deleted forKey: @"deleted"];
  }
}

- (void) dealloc
{
  [__id release_stub];
  [__name release_stub];
  [__photo_url release_stub];
  [__apns_cert release_stub];
  [super dealloc_stub];
}

- (NSData *) id {
  return [[__id retain_stub] autorelease_stub];
}

- (void) setId: (NSData *) id {
  [id retain_stub];
  [__id release_stub];
  __id = id;
  __id_isset = YES;
}

- (BOOL) idIsSet {
  return __id_isset;
}

- (void) unsetId {
  [__id release_stub];
  __id = nil;
  __id_isset = NO;
}

- (NSString *) name {
  return [[__name retain_stub] autorelease_stub];
}

- (void) setName: (NSString *) name {
  [name retain_stub];
  [__name release_stub];
  __name = name;
  __name_isset = YES;
}

- (BOOL) nameIsSet {
  return __name_isset;
}

- (void) unsetName {
  [__name release_stub];
  __name = nil;
  __name_isset = NO;
}

- (NSString *) photo_url {
  return [[__photo_url retain_stub] autorelease_stub];
}

- (void) setPhoto_url: (NSString *) photo_url {
  [photo_url retain_stub];
  [__photo_url release_stub];
  __photo_url = photo_url;
  __photo_url_isset = YES;
}

- (BOOL) photo_urlIsSet {
  return __photo_url_isset;
}

- (void) unsetPhoto_url {
  [__photo_url release_stub];
  __photo_url = nil;
  __photo_url_isset = NO;
}

- (BOOL) enabled {
  return __enabled;
}

- (void) setEnabled: (BOOL) enabled {
  __enabled = enabled;
  __enabled_isset = YES;
}

- (BOOL) enabledIsSet {
  return __enabled_isset;
}

- (void) unsetEnabled {
  __enabled_isset = NO;
}

- (LYRTApnsCert *) apns_cert {
  return [[__apns_cert retain_stub] autorelease_stub];
}

- (void) setApns_cert: (LYRTApnsCert *) apns_cert {
  [apns_cert retain_stub];
  [__apns_cert release_stub];
  __apns_cert = apns_cert;
  __apns_cert_isset = YES;
}

- (BOOL) apns_certIsSet {
  return __apns_cert_isset;
}

- (void) unsetApns_cert {
  [__apns_cert release_stub];
  __apns_cert = nil;
  __apns_cert_isset = NO;
}

- (BOOL) deleted {
  return __deleted;
}

- (void) setDeleted: (BOOL) deleted {
  __deleted = deleted;
  __deleted_isset = YES;
}

- (BOOL) deletedIsSet {
  return __deleted_isset;
}

- (void) unsetDeleted {
  __deleted_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setName: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setPhoto_url: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setEnabled: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_STRUCT) {
          LYRTApnsCert *fieldValue = [[LYRTApnsCert alloc] init];
          [fieldValue read: inProtocol];
          [self setApns_cert: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setDeleted: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"App"];
  if (__id_isset) {
    if (__id != nil) {
      [outProtocol writeFieldBeginWithName: @"id" type: TType_STRING fieldID: 1];
      [outProtocol writeBinary: __id];
      [outProtocol writeFieldEnd];
    }
  }
  if (__name_isset) {
    if (__name != nil) {
      [outProtocol writeFieldBeginWithName: @"name" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __name];
      [outProtocol writeFieldEnd];
    }
  }
  if (__photo_url_isset) {
    if (__photo_url != nil) {
      [outProtocol writeFieldBeginWithName: @"photo_url" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __photo_url];
      [outProtocol writeFieldEnd];
    }
  }
  if (__enabled_isset) {
    [outProtocol writeFieldBeginWithName: @"enabled" type: TType_BOOL fieldID: 4];
    [outProtocol writeBool: __enabled];
    [outProtocol writeFieldEnd];
  }
  if (__apns_cert_isset) {
    if (__apns_cert != nil) {
      [outProtocol writeFieldBeginWithName: @"apns_cert" type: TType_STRUCT fieldID: 5];
      [__apns_cert write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__deleted_isset) {
    [outProtocol writeFieldBeginWithName: @"deleted" type: TType_BOOL fieldID: 6];
    [outProtocol writeBool: __deleted];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"App("];
  [ms appendString: @"id:"];
  [ms appendFormat: @"\"%@\"", __id];
  [ms appendString: @",name:"];
  [ms appendFormat: @"\"%@\"", __name];
  [ms appendString: @",photo_url:"];
  [ms appendFormat: @"\"%@\"", __photo_url];
  [ms appendString: @",enabled:"];
  [ms appendFormat: @"%i", __enabled];
  [ms appendString: @",apns_cert:"];
  [ms appendFormat: @"%@", __apns_cert];
  [ms appendString: @",deleted:"];
  [ms appendFormat: @"%i", __deleted];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation LYRTAccountApps

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAccount: (LYRTAccount *) account apps: (LYRTApps) apps
{
  self = [super init];
  __account = [account retain_stub];
  __account_isset = YES;
  __apps = [apps retain_stub];
  __apps_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"account"])
  {
    __account = [[decoder decodeObjectForKey: @"account"] retain_stub];
    __account_isset = YES;
  }
  if ([decoder containsValueForKey: @"apps"])
  {
    __apps = [[decoder decodeObjectForKey: @"apps"] retain_stub];
    __apps_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__account_isset)
  {
    [encoder encodeObject: __account forKey: @"account"];
  }
  if (__apps_isset)
  {
    [encoder encodeObject: __apps forKey: @"apps"];
  }
}

- (void) dealloc
{
  [__account release_stub];
  [__apps release_stub];
  [super dealloc_stub];
}

- (LYRTAccount *) account {
  return [[__account retain_stub] autorelease_stub];
}

- (void) setAccount: (LYRTAccount *) account {
  [account retain_stub];
  [__account release_stub];
  __account = account;
  __account_isset = YES;
}

- (BOOL) accountIsSet {
  return __account_isset;
}

- (void) unsetAccount {
  [__account release_stub];
  __account = nil;
  __account_isset = NO;
}

- (NSMutableArray *) apps {
  return [[__apps retain_stub] autorelease_stub];
}

- (void) setApps: (NSMutableArray *) apps {
  [apps retain_stub];
  [__apps release_stub];
  __apps = apps;
  __apps_isset = YES;
}

- (BOOL) appsIsSet {
  return __apps_isset;
}

- (void) unsetApps {
  [__apps release_stub];
  __apps = nil;
  __apps_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTAccount *fieldValue = [[LYRTAccount alloc] init];
          [fieldValue read: inProtocol];
          [self setAccount: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_LIST) {
          int _size0;
          [inProtocol readListBeginReturningElementType: NULL size: &_size0];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size0];
          int _i1;
          for (_i1 = 0; _i1 < _size0; ++_i1)
          {
            LYRTApp *_elem2 = [[LYRTApp alloc] init];
            [_elem2 read: inProtocol];
            [fieldValue addObject: _elem2];
            [_elem2 release_stub];
          }
          [inProtocol readListEnd];
          [self setApps: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"AccountApps"];
  if (__account_isset) {
    if (__account != nil) {
      [outProtocol writeFieldBeginWithName: @"account" type: TType_STRUCT fieldID: 1];
      [__account write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__apps_isset) {
    if (__apps != nil) {
      [outProtocol writeFieldBeginWithName: @"apps" type: TType_LIST fieldID: 2];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__apps count]];
        int i4;
        for (i4 = 0; i4 < [__apps count]; i4++)
        {
          [[__apps objectAtIndex: i4] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AccountApps("];
  [ms appendString: @"account:"];
  [ms appendFormat: @"%@", __account];
  [ms appendString: @",apps:"];
  [ms appendFormat: @"%@", __apps];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation LYRTPublicKey

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
  self.disabled = NO;

  self.deleted = NO;

#endif
  return self;
}

- (id) initWithProvider_id: (LYRTUUID) provider_id key_id: (LYRTUUID) key_id public_key: (NSData *) public_key disabled: (BOOL) disabled deleted: (BOOL) deleted name: (NSString *) name
{
  self = [super init];
  __provider_id = [provider_id retain_stub];
  __provider_id_isset = YES;
  __key_id = [key_id retain_stub];
  __key_id_isset = YES;
  __public_key = [public_key retain_stub];
  __public_key_isset = YES;
  __disabled = disabled;
  __disabled_isset = YES;
  __deleted = deleted;
  __deleted_isset = YES;
  __name = [name retain_stub];
  __name_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"provider_id"])
  {
    __provider_id = [[decoder decodeObjectForKey: @"provider_id"] retain_stub];
    __provider_id_isset = YES;
  }
  if ([decoder containsValueForKey: @"key_id"])
  {
    __key_id = [[decoder decodeObjectForKey: @"key_id"] retain_stub];
    __key_id_isset = YES;
  }
  if ([decoder containsValueForKey: @"public_key"])
  {
    __public_key = [[decoder decodeObjectForKey: @"public_key"] retain_stub];
    __public_key_isset = YES;
  }
  if ([decoder containsValueForKey: @"disabled"])
  {
    __disabled = [decoder decodeBoolForKey: @"disabled"];
    __disabled_isset = YES;
  }
  if ([decoder containsValueForKey: @"deleted"])
  {
    __deleted = [decoder decodeBoolForKey: @"deleted"];
    __deleted_isset = YES;
  }
  if ([decoder containsValueForKey: @"name"])
  {
    __name = [[decoder decodeObjectForKey: @"name"] retain_stub];
    __name_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__provider_id_isset)
  {
    [encoder encodeObject: __provider_id forKey: @"provider_id"];
  }
  if (__key_id_isset)
  {
    [encoder encodeObject: __key_id forKey: @"key_id"];
  }
  if (__public_key_isset)
  {
    [encoder encodeObject: __public_key forKey: @"public_key"];
  }
  if (__disabled_isset)
  {
    [encoder encodeBool: __disabled forKey: @"disabled"];
  }
  if (__deleted_isset)
  {
    [encoder encodeBool: __deleted forKey: @"deleted"];
  }
  if (__name_isset)
  {
    [encoder encodeObject: __name forKey: @"name"];
  }
}

- (void) dealloc
{
  [__provider_id release_stub];
  [__key_id release_stub];
  [__public_key release_stub];
  [__name release_stub];
  [super dealloc_stub];
}

- (NSData *) provider_id {
  return [[__provider_id retain_stub] autorelease_stub];
}

- (void) setProvider_id: (NSData *) provider_id {
  [provider_id retain_stub];
  [__provider_id release_stub];
  __provider_id = provider_id;
  __provider_id_isset = YES;
}

- (BOOL) provider_idIsSet {
  return __provider_id_isset;
}

- (void) unsetProvider_id {
  [__provider_id release_stub];
  __provider_id = nil;
  __provider_id_isset = NO;
}

- (NSData *) key_id {
  return [[__key_id retain_stub] autorelease_stub];
}

- (void) setKey_id: (NSData *) key_id {
  [key_id retain_stub];
  [__key_id release_stub];
  __key_id = key_id;
  __key_id_isset = YES;
}

- (BOOL) key_idIsSet {
  return __key_id_isset;
}

- (void) unsetKey_id {
  [__key_id release_stub];
  __key_id = nil;
  __key_id_isset = NO;
}

- (NSData *) public_key {
  return [[__public_key retain_stub] autorelease_stub];
}

- (void) setPublic_key: (NSData *) public_key {
  [public_key retain_stub];
  [__public_key release_stub];
  __public_key = public_key;
  __public_key_isset = YES;
}

- (BOOL) public_keyIsSet {
  return __public_key_isset;
}

- (void) unsetPublic_key {
  [__public_key release_stub];
  __public_key = nil;
  __public_key_isset = NO;
}

- (BOOL) disabled {
  return __disabled;
}

- (void) setDisabled: (BOOL) disabled {
  __disabled = disabled;
  __disabled_isset = YES;
}

- (BOOL) disabledIsSet {
  return __disabled_isset;
}

- (void) unsetDisabled {
  __disabled_isset = NO;
}

- (BOOL) deleted {
  return __deleted;
}

- (void) setDeleted: (BOOL) deleted {
  __deleted = deleted;
  __deleted_isset = YES;
}

- (BOOL) deletedIsSet {
  return __deleted_isset;
}

- (void) unsetDeleted {
  __deleted_isset = NO;
}

- (NSString *) name {
  return [[__name retain_stub] autorelease_stub];
}

- (void) setName: (NSString *) name {
  [name retain_stub];
  [__name release_stub];
  __name = name;
  __name_isset = YES;
}

- (BOOL) nameIsSet {
  return __name_isset;
}

- (void) unsetName {
  [__name release_stub];
  __name = nil;
  __name_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setProvider_id: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setKey_id: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setPublic_key: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setDisabled: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setDeleted: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setName: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"PublicKey"];
  if (__provider_id_isset) {
    if (__provider_id != nil) {
      [outProtocol writeFieldBeginWithName: @"provider_id" type: TType_STRING fieldID: 1];
      [outProtocol writeBinary: __provider_id];
      [outProtocol writeFieldEnd];
    }
  }
  if (__key_id_isset) {
    if (__key_id != nil) {
      [outProtocol writeFieldBeginWithName: @"key_id" type: TType_STRING fieldID: 2];
      [outProtocol writeBinary: __key_id];
      [outProtocol writeFieldEnd];
    }
  }
  if (__public_key_isset) {
    if (__public_key != nil) {
      [outProtocol writeFieldBeginWithName: @"public_key" type: TType_STRING fieldID: 3];
      [outProtocol writeBinary: __public_key];
      [outProtocol writeFieldEnd];
    }
  }
  if (__disabled_isset) {
    [outProtocol writeFieldBeginWithName: @"disabled" type: TType_BOOL fieldID: 4];
    [outProtocol writeBool: __disabled];
    [outProtocol writeFieldEnd];
  }
  if (__deleted_isset) {
    [outProtocol writeFieldBeginWithName: @"deleted" type: TType_BOOL fieldID: 5];
    [outProtocol writeBool: __deleted];
    [outProtocol writeFieldEnd];
  }
  if (__name_isset) {
    if (__name != nil) {
      [outProtocol writeFieldBeginWithName: @"name" type: TType_STRING fieldID: 6];
      [outProtocol writeString: __name];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"PublicKey("];
  [ms appendString: @"provider_id:"];
  [ms appendFormat: @"\"%@\"", __provider_id];
  [ms appendString: @",key_id:"];
  [ms appendFormat: @"\"%@\"", __key_id];
  [ms appendString: @",public_key:"];
  [ms appendFormat: @"\"%@\"", __public_key];
  [ms appendString: @",disabled:"];
  [ms appendFormat: @"%i", __disabled];
  [ms appendString: @",deleted:"];
  [ms appendFormat: @"%i", __deleted];
  [ms appendString: @",name:"];
  [ms appendFormat: @"\"%@\"", __name];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation LYRTUser

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithId: (LYRTUUID) id remote_id: (NSString *) remote_id
{
  self = [super init];
  __id = [id retain_stub];
  __id_isset = YES;
  __remote_id = [remote_id retain_stub];
  __remote_id_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"id"])
  {
    __id = [[decoder decodeObjectForKey: @"id"] retain_stub];
    __id_isset = YES;
  }
  if ([decoder containsValueForKey: @"remote_id"])
  {
    __remote_id = [[decoder decodeObjectForKey: @"remote_id"] retain_stub];
    __remote_id_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__id_isset)
  {
    [encoder encodeObject: __id forKey: @"id"];
  }
  if (__remote_id_isset)
  {
    [encoder encodeObject: __remote_id forKey: @"remote_id"];
  }
}

- (void) dealloc
{
  [__id release_stub];
  [__remote_id release_stub];
  [super dealloc_stub];
}

- (NSData *) id {
  return [[__id retain_stub] autorelease_stub];
}

- (void) setId: (NSData *) id {
  [id retain_stub];
  [__id release_stub];
  __id = id;
  __id_isset = YES;
}

- (BOOL) idIsSet {
  return __id_isset;
}

- (void) unsetId {
  [__id release_stub];
  __id = nil;
  __id_isset = NO;
}

- (NSString *) remote_id {
  return [[__remote_id retain_stub] autorelease_stub];
}

- (void) setRemote_id: (NSString *) remote_id {
  [remote_id retain_stub];
  [__remote_id release_stub];
  __remote_id = remote_id;
  __remote_id_isset = YES;
}

- (BOOL) remote_idIsSet {
  return __remote_id_isset;
}

- (void) unsetRemote_id {
  [__remote_id release_stub];
  __remote_id = nil;
  __remote_id_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setRemote_id: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"User"];
  if (__id_isset) {
    if (__id != nil) {
      [outProtocol writeFieldBeginWithName: @"id" type: TType_STRING fieldID: 1];
      [outProtocol writeBinary: __id];
      [outProtocol writeFieldEnd];
    }
  }
  if (__remote_id_isset) {
    if (__remote_id != nil) {
      [outProtocol writeFieldBeginWithName: @"remote_id" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __remote_id];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"User("];
  [ms appendString: @"id:"];
  [ms appendFormat: @"\"%@\"", __id];
  [ms appendString: @",remote_id:"];
  [ms appendFormat: @"\"%@\"", __remote_id];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation LYRTSession

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithApp_id: (LYRTUUID) app_id user_id: (LYRTUUID) user_id device_id: (LYRTUUID) device_id session_token: (NSString *) session_token expiration: (int64_t) expiration
{
  self = [super init];
  __app_id = [app_id retain_stub];
  __app_id_isset = YES;
  __user_id = [user_id retain_stub];
  __user_id_isset = YES;
  __device_id = [device_id retain_stub];
  __device_id_isset = YES;
  __session_token = [session_token retain_stub];
  __session_token_isset = YES;
  __expiration = expiration;
  __expiration_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"app_id"])
  {
    __app_id = [[decoder decodeObjectForKey: @"app_id"] retain_stub];
    __app_id_isset = YES;
  }
  if ([decoder containsValueForKey: @"user_id"])
  {
    __user_id = [[decoder decodeObjectForKey: @"user_id"] retain_stub];
    __user_id_isset = YES;
  }
  if ([decoder containsValueForKey: @"device_id"])
  {
    __device_id = [[decoder decodeObjectForKey: @"device_id"] retain_stub];
    __device_id_isset = YES;
  }
  if ([decoder containsValueForKey: @"session_token"])
  {
    __session_token = [[decoder decodeObjectForKey: @"session_token"] retain_stub];
    __session_token_isset = YES;
  }
  if ([decoder containsValueForKey: @"expiration"])
  {
    __expiration = [decoder decodeInt64ForKey: @"expiration"];
    __expiration_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__app_id_isset)
  {
    [encoder encodeObject: __app_id forKey: @"app_id"];
  }
  if (__user_id_isset)
  {
    [encoder encodeObject: __user_id forKey: @"user_id"];
  }
  if (__device_id_isset)
  {
    [encoder encodeObject: __device_id forKey: @"device_id"];
  }
  if (__session_token_isset)
  {
    [encoder encodeObject: __session_token forKey: @"session_token"];
  }
  if (__expiration_isset)
  {
    [encoder encodeInt64: __expiration forKey: @"expiration"];
  }
}

- (void) dealloc
{
  [__app_id release_stub];
  [__user_id release_stub];
  [__device_id release_stub];
  [__session_token release_stub];
  [super dealloc_stub];
}

- (NSData *) app_id {
  return [[__app_id retain_stub] autorelease_stub];
}

- (void) setApp_id: (NSData *) app_id {
  [app_id retain_stub];
  [__app_id release_stub];
  __app_id = app_id;
  __app_id_isset = YES;
}

- (BOOL) app_idIsSet {
  return __app_id_isset;
}

- (void) unsetApp_id {
  [__app_id release_stub];
  __app_id = nil;
  __app_id_isset = NO;
}

- (NSData *) user_id {
  return [[__user_id retain_stub] autorelease_stub];
}

- (void) setUser_id: (NSData *) user_id {
  [user_id retain_stub];
  [__user_id release_stub];
  __user_id = user_id;
  __user_id_isset = YES;
}

- (BOOL) user_idIsSet {
  return __user_id_isset;
}

- (void) unsetUser_id {
  [__user_id release_stub];
  __user_id = nil;
  __user_id_isset = NO;
}

- (NSData *) device_id {
  return [[__device_id retain_stub] autorelease_stub];
}

- (void) setDevice_id: (NSData *) device_id {
  [device_id retain_stub];
  [__device_id release_stub];
  __device_id = device_id;
  __device_id_isset = YES;
}

- (BOOL) device_idIsSet {
  return __device_id_isset;
}

- (void) unsetDevice_id {
  [__device_id release_stub];
  __device_id = nil;
  __device_id_isset = NO;
}

- (NSString *) session_token {
  return [[__session_token retain_stub] autorelease_stub];
}

- (void) setSession_token: (NSString *) session_token {
  [session_token retain_stub];
  [__session_token release_stub];
  __session_token = session_token;
  __session_token_isset = YES;
}

- (BOOL) session_tokenIsSet {
  return __session_token_isset;
}

- (void) unsetSession_token {
  [__session_token release_stub];
  __session_token = nil;
  __session_token_isset = NO;
}

- (int64_t) expiration {
  return __expiration;
}

- (void) setExpiration: (int64_t) expiration {
  __expiration = expiration;
  __expiration_isset = YES;
}

- (BOOL) expirationIsSet {
  return __expiration_isset;
}

- (void) unsetExpiration {
  __expiration_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setApp_id: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setUser_id: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setDevice_id: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSession_token: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setExpiration: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Session"];
  if (__app_id_isset) {
    if (__app_id != nil) {
      [outProtocol writeFieldBeginWithName: @"app_id" type: TType_STRING fieldID: 1];
      [outProtocol writeBinary: __app_id];
      [outProtocol writeFieldEnd];
    }
  }
  if (__user_id_isset) {
    if (__user_id != nil) {
      [outProtocol writeFieldBeginWithName: @"user_id" type: TType_STRING fieldID: 2];
      [outProtocol writeBinary: __user_id];
      [outProtocol writeFieldEnd];
    }
  }
  if (__device_id_isset) {
    if (__device_id != nil) {
      [outProtocol writeFieldBeginWithName: @"device_id" type: TType_STRING fieldID: 3];
      [outProtocol writeBinary: __device_id];
      [outProtocol writeFieldEnd];
    }
  }
  if (__session_token_isset) {
    if (__session_token != nil) {
      [outProtocol writeFieldBeginWithName: @"session_token" type: TType_STRING fieldID: 4];
      [outProtocol writeString: __session_token];
      [outProtocol writeFieldEnd];
    }
  }
  if (__expiration_isset) {
    [outProtocol writeFieldBeginWithName: @"expiration" type: TType_I64 fieldID: 5];
    [outProtocol writeI64: __expiration];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Session("];
  [ms appendString: @"app_id:"];
  [ms appendFormat: @"\"%@\"", __app_id];
  [ms appendString: @",user_id:"];
  [ms appendFormat: @"\"%@\"", __user_id];
  [ms appendString: @",device_id:"];
  [ms appendFormat: @"\"%@\"", __device_id];
  [ms appendString: @",session_token:"];
  [ms appendFormat: @"\"%@\"", __session_token];
  [ms appendString: @",expiration:"];
  [ms appendFormat: @"%qi", __expiration];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation LYRTDevice

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithId: (LYRTUUID) id local_id: (NSString *) local_id hardware: (NSString *) hardware os: (NSString *) os framework: (NSString *) framework application: (NSString *) application
{
  self = [super init];
  __id = [id retain_stub];
  __id_isset = YES;
  __local_id = [local_id retain_stub];
  __local_id_isset = YES;
  __hardware = [hardware retain_stub];
  __hardware_isset = YES;
  __os = [os retain_stub];
  __os_isset = YES;
  __framework = [framework retain_stub];
  __framework_isset = YES;
  __application = [application retain_stub];
  __application_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"id"])
  {
    __id = [[decoder decodeObjectForKey: @"id"] retain_stub];
    __id_isset = YES;
  }
  if ([decoder containsValueForKey: @"local_id"])
  {
    __local_id = [[decoder decodeObjectForKey: @"local_id"] retain_stub];
    __local_id_isset = YES;
  }
  if ([decoder containsValueForKey: @"hardware"])
  {
    __hardware = [[decoder decodeObjectForKey: @"hardware"] retain_stub];
    __hardware_isset = YES;
  }
  if ([decoder containsValueForKey: @"os"])
  {
    __os = [[decoder decodeObjectForKey: @"os"] retain_stub];
    __os_isset = YES;
  }
  if ([decoder containsValueForKey: @"framework"])
  {
    __framework = [[decoder decodeObjectForKey: @"framework"] retain_stub];
    __framework_isset = YES;
  }
  if ([decoder containsValueForKey: @"application"])
  {
    __application = [[decoder decodeObjectForKey: @"application"] retain_stub];
    __application_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__id_isset)
  {
    [encoder encodeObject: __id forKey: @"id"];
  }
  if (__local_id_isset)
  {
    [encoder encodeObject: __local_id forKey: @"local_id"];
  }
  if (__hardware_isset)
  {
    [encoder encodeObject: __hardware forKey: @"hardware"];
  }
  if (__os_isset)
  {
    [encoder encodeObject: __os forKey: @"os"];
  }
  if (__framework_isset)
  {
    [encoder encodeObject: __framework forKey: @"framework"];
  }
  if (__application_isset)
  {
    [encoder encodeObject: __application forKey: @"application"];
  }
}

- (void) dealloc
{
  [__id release_stub];
  [__local_id release_stub];
  [__hardware release_stub];
  [__os release_stub];
  [__framework release_stub];
  [__application release_stub];
  [super dealloc_stub];
}

- (NSData *) id {
  return [[__id retain_stub] autorelease_stub];
}

- (void) setId: (NSData *) id {
  [id retain_stub];
  [__id release_stub];
  __id = id;
  __id_isset = YES;
}

- (BOOL) idIsSet {
  return __id_isset;
}

- (void) unsetId {
  [__id release_stub];
  __id = nil;
  __id_isset = NO;
}

- (NSString *) local_id {
  return [[__local_id retain_stub] autorelease_stub];
}

- (void) setLocal_id: (NSString *) local_id {
  [local_id retain_stub];
  [__local_id release_stub];
  __local_id = local_id;
  __local_id_isset = YES;
}

- (BOOL) local_idIsSet {
  return __local_id_isset;
}

- (void) unsetLocal_id {
  [__local_id release_stub];
  __local_id = nil;
  __local_id_isset = NO;
}

- (NSString *) hardware {
  return [[__hardware retain_stub] autorelease_stub];
}

- (void) setHardware: (NSString *) hardware {
  [hardware retain_stub];
  [__hardware release_stub];
  __hardware = hardware;
  __hardware_isset = YES;
}

- (BOOL) hardwareIsSet {
  return __hardware_isset;
}

- (void) unsetHardware {
  [__hardware release_stub];
  __hardware = nil;
  __hardware_isset = NO;
}

- (NSString *) os {
  return [[__os retain_stub] autorelease_stub];
}

- (void) setOs: (NSString *) os {
  [os retain_stub];
  [__os release_stub];
  __os = os;
  __os_isset = YES;
}

- (BOOL) osIsSet {
  return __os_isset;
}

- (void) unsetOs {
  [__os release_stub];
  __os = nil;
  __os_isset = NO;
}

- (NSString *) framework {
  return [[__framework retain_stub] autorelease_stub];
}

- (void) setFramework: (NSString *) framework {
  [framework retain_stub];
  [__framework release_stub];
  __framework = framework;
  __framework_isset = YES;
}

- (BOOL) frameworkIsSet {
  return __framework_isset;
}

- (void) unsetFramework {
  [__framework release_stub];
  __framework = nil;
  __framework_isset = NO;
}

- (NSString *) application {
  return [[__application retain_stub] autorelease_stub];
}

- (void) setApplication: (NSString *) application {
  [application retain_stub];
  [__application release_stub];
  __application = application;
  __application_isset = YES;
}

- (BOOL) applicationIsSet {
  return __application_isset;
}

- (void) unsetApplication {
  [__application release_stub];
  __application = nil;
  __application_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setLocal_id: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setHardware: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setOs: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setFramework: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setApplication: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Device"];
  if (__id_isset) {
    if (__id != nil) {
      [outProtocol writeFieldBeginWithName: @"id" type: TType_STRING fieldID: 1];
      [outProtocol writeBinary: __id];
      [outProtocol writeFieldEnd];
    }
  }
  if (__local_id_isset) {
    if (__local_id != nil) {
      [outProtocol writeFieldBeginWithName: @"local_id" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __local_id];
      [outProtocol writeFieldEnd];
    }
  }
  if (__hardware_isset) {
    if (__hardware != nil) {
      [outProtocol writeFieldBeginWithName: @"hardware" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __hardware];
      [outProtocol writeFieldEnd];
    }
  }
  if (__os_isset) {
    if (__os != nil) {
      [outProtocol writeFieldBeginWithName: @"os" type: TType_STRING fieldID: 4];
      [outProtocol writeString: __os];
      [outProtocol writeFieldEnd];
    }
  }
  if (__framework_isset) {
    if (__framework != nil) {
      [outProtocol writeFieldBeginWithName: @"framework" type: TType_STRING fieldID: 5];
      [outProtocol writeString: __framework];
      [outProtocol writeFieldEnd];
    }
  }
  if (__application_isset) {
    if (__application != nil) {
      [outProtocol writeFieldBeginWithName: @"application" type: TType_STRING fieldID: 6];
      [outProtocol writeString: __application];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Device("];
  [ms appendString: @"id:"];
  [ms appendFormat: @"\"%@\"", __id];
  [ms appendString: @",local_id:"];
  [ms appendFormat: @"\"%@\"", __local_id];
  [ms appendString: @",hardware:"];
  [ms appendFormat: @"\"%@\"", __hardware];
  [ms appendString: @",os:"];
  [ms appendFormat: @"\"%@\"", __os];
  [ms appendString: @",framework:"];
  [ms appendFormat: @"\"%@\"", __framework];
  [ms appendString: @",application:"];
  [ms appendFormat: @"\"%@\"", __application];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation LYRTPushToken

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithType: (int) type push_token: (NSString *) push_token device_id: (LYRTUUID) device_id
{
  self = [super init];
  __type = type;
  __type_isset = YES;
  __push_token = [push_token retain_stub];
  __push_token_isset = YES;
  __device_id = [device_id retain_stub];
  __device_id_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"type"])
  {
    __type = [decoder decodeIntForKey: @"type"];
    __type_isset = YES;
  }
  if ([decoder containsValueForKey: @"push_token"])
  {
    __push_token = [[decoder decodeObjectForKey: @"push_token"] retain_stub];
    __push_token_isset = YES;
  }
  if ([decoder containsValueForKey: @"device_id"])
  {
    __device_id = [[decoder decodeObjectForKey: @"device_id"] retain_stub];
    __device_id_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__type_isset)
  {
    [encoder encodeInt: __type forKey: @"type"];
  }
  if (__push_token_isset)
  {
    [encoder encodeObject: __push_token forKey: @"push_token"];
  }
  if (__device_id_isset)
  {
    [encoder encodeObject: __device_id forKey: @"device_id"];
  }
}

- (void) dealloc
{
  [__push_token release_stub];
  [__device_id release_stub];
  [super dealloc_stub];
}

- (int) type {
  return __type;
}

- (void) setType: (int) type {
  __type = type;
  __type_isset = YES;
}

- (BOOL) typeIsSet {
  return __type_isset;
}

- (void) unsetType {
  __type_isset = NO;
}

- (NSString *) push_token {
  return [[__push_token retain_stub] autorelease_stub];
}

- (void) setPush_token: (NSString *) push_token {
  [push_token retain_stub];
  [__push_token release_stub];
  __push_token = push_token;
  __push_token_isset = YES;
}

- (BOOL) push_tokenIsSet {
  return __push_token_isset;
}

- (void) unsetPush_token {
  [__push_token release_stub];
  __push_token = nil;
  __push_token_isset = NO;
}

- (NSData *) device_id {
  return [[__device_id retain_stub] autorelease_stub];
}

- (void) setDevice_id: (NSData *) device_id {
  [device_id retain_stub];
  [__device_id release_stub];
  __device_id = device_id;
  __device_id_isset = YES;
}

- (BOOL) device_idIsSet {
  return __device_id_isset;
}

- (void) unsetDevice_id {
  [__device_id release_stub];
  __device_id = nil;
  __device_id_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int fieldValue = [inProtocol readI32];
          [self setType: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setPush_token: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setDevice_id: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"PushToken"];
  if (__type_isset) {
    [outProtocol writeFieldBeginWithName: @"type" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __type];
    [outProtocol writeFieldEnd];
  }
  if (__push_token_isset) {
    if (__push_token != nil) {
      [outProtocol writeFieldBeginWithName: @"push_token" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __push_token];
      [outProtocol writeFieldEnd];
    }
  }
  if (__device_id_isset) {
    if (__device_id != nil) {
      [outProtocol writeFieldBeginWithName: @"device_id" type: TType_STRING fieldID: 3];
      [outProtocol writeBinary: __device_id];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"PushToken("];
  [ms appendString: @"type:"];
  [ms appendFormat: @"%i", __type];
  [ms appendString: @",push_token:"];
  [ms appendFormat: @"\"%@\"", __push_token];
  [ms appendString: @",device_id:"];
  [ms appendFormat: @"\"%@\"", __device_id];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end


@implementation LYRTctrlConstants
+ (void) initialize {
}
@end

@interface LYRTcreateAccount_args : NSObject <TBase, NSCoding> {
  LYRTAccount * __account;

  BOOL __account_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=account, setter=setAccount:) LYRTAccount * account;
#endif

- (id) init;
- (id) initWithAccount: (LYRTAccount *) account;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTAccount *) account;
- (void) setAccount: (LYRTAccount *) account;
#endif
- (BOOL) accountIsSet;

@end

@implementation LYRTcreateAccount_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAccount: (LYRTAccount *) account
{
  self = [super init];
  __account = [account retain_stub];
  __account_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"account"])
  {
    __account = [[decoder decodeObjectForKey: @"account"] retain_stub];
    __account_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__account_isset)
  {
    [encoder encodeObject: __account forKey: @"account"];
  }
}

- (void) dealloc
{
  [__account release_stub];
  [super dealloc_stub];
}

- (LYRTAccount *) account {
  return [[__account retain_stub] autorelease_stub];
}

- (void) setAccount: (LYRTAccount *) account {
  [account retain_stub];
  [__account release_stub];
  __account = account;
  __account_isset = YES;
}

- (BOOL) accountIsSet {
  return __account_isset;
}

- (void) unsetAccount {
  [__account release_stub];
  __account = nil;
  __account_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTAccount *fieldValue = [[LYRTAccount alloc] init];
          [fieldValue read: inProtocol];
          [self setAccount: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"createAccount_args"];
  if (__account_isset) {
    if (__account != nil) {
      [outProtocol writeFieldBeginWithName: @"account" type: TType_STRUCT fieldID: 1];
      [__account write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"createAccount_args("];
  [ms appendString: @"account:"];
  [ms appendFormat: @"%@", __account];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTCreateAccount_result : NSObject <TBase, NSCoding> {
  LYRTAccount * __success;
  LYRTInternalException * __intException;
  LYRTBadRequestException * __brException;
  LYRTConflictException * __cfException;

  BOOL __success_isset;
  BOOL __intException_isset;
  BOOL __brException_isset;
  BOOL __cfException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) LYRTAccount * success;
@property (nonatomic, retain, getter=intException, setter=setIntException:) LYRTInternalException * intException;
@property (nonatomic, retain, getter=brException, setter=setBrException:) LYRTBadRequestException * brException;
@property (nonatomic, retain, getter=cfException, setter=setCfException:) LYRTConflictException * cfException;
#endif

- (id) init;
- (id) initWithSuccess: (LYRTAccount *) success intException: (LYRTInternalException *) intException brException: (LYRTBadRequestException *) brException cfException: (LYRTConflictException *) cfException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTAccount *) success;
- (void) setSuccess: (LYRTAccount *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (LYRTInternalException *) intException;
- (void) setIntException: (LYRTInternalException *) intException;
#endif
- (BOOL) intExceptionIsSet;

#if !__has_feature(objc_arc)
- (LYRTBadRequestException *) brException;
- (void) setBrException: (LYRTBadRequestException *) brException;
#endif
- (BOOL) brExceptionIsSet;

#if !__has_feature(objc_arc)
- (LYRTConflictException *) cfException;
- (void) setCfException: (LYRTConflictException *) cfException;
#endif
- (BOOL) cfExceptionIsSet;

@end

@implementation LYRTCreateAccount_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (LYRTAccount *) success intException: (LYRTInternalException *) intException brException: (LYRTBadRequestException *) brException cfException: (LYRTConflictException *) cfException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __intException = [intException retain_stub];
  __intException_isset = YES;
  __brException = [brException retain_stub];
  __brException_isset = YES;
  __cfException = [cfException retain_stub];
  __cfException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"intException"])
  {
    __intException = [[decoder decodeObjectForKey: @"intException"] retain_stub];
    __intException_isset = YES;
  }
  if ([decoder containsValueForKey: @"brException"])
  {
    __brException = [[decoder decodeObjectForKey: @"brException"] retain_stub];
    __brException_isset = YES;
  }
  if ([decoder containsValueForKey: @"cfException"])
  {
    __cfException = [[decoder decodeObjectForKey: @"cfException"] retain_stub];
    __cfException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__intException_isset)
  {
    [encoder encodeObject: __intException forKey: @"intException"];
  }
  if (__brException_isset)
  {
    [encoder encodeObject: __brException forKey: @"brException"];
  }
  if (__cfException_isset)
  {
    [encoder encodeObject: __cfException forKey: @"cfException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__intException release_stub];
  [__brException release_stub];
  [__cfException release_stub];
  [super dealloc_stub];
}

- (LYRTAccount *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (LYRTAccount *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (LYRTInternalException *) intException {
  return [[__intException retain_stub] autorelease_stub];
}

- (void) setIntException: (LYRTInternalException *) intException {
  [intException retain_stub];
  [__intException release_stub];
  __intException = intException;
  __intException_isset = YES;
}

- (BOOL) intExceptionIsSet {
  return __intException_isset;
}

- (void) unsetIntException {
  [__intException release_stub];
  __intException = nil;
  __intException_isset = NO;
}

- (LYRTBadRequestException *) brException {
  return [[__brException retain_stub] autorelease_stub];
}

- (void) setBrException: (LYRTBadRequestException *) brException {
  [brException retain_stub];
  [__brException release_stub];
  __brException = brException;
  __brException_isset = YES;
}

- (BOOL) brExceptionIsSet {
  return __brException_isset;
}

- (void) unsetBrException {
  [__brException release_stub];
  __brException = nil;
  __brException_isset = NO;
}

- (LYRTConflictException *) cfException {
  return [[__cfException retain_stub] autorelease_stub];
}

- (void) setCfException: (LYRTConflictException *) cfException {
  [cfException retain_stub];
  [__cfException release_stub];
  __cfException = cfException;
  __cfException_isset = YES;
}

- (BOOL) cfExceptionIsSet {
  return __cfException_isset;
}

- (void) unsetCfException {
  [__cfException release_stub];
  __cfException = nil;
  __cfException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          LYRTAccount *fieldValue = [[LYRTAccount alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTInternalException *fieldValue = [[LYRTInternalException alloc] init];
          [fieldValue read: inProtocol];
          [self setIntException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          LYRTBadRequestException *fieldValue = [[LYRTBadRequestException alloc] init];
          [fieldValue read: inProtocol];
          [self setBrException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          LYRTConflictException *fieldValue = [[LYRTConflictException alloc] init];
          [fieldValue read: inProtocol];
          [self setCfException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CreateAccount_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__intException_isset) {
    if (__intException != nil) {
      [outProtocol writeFieldBeginWithName: @"intException" type: TType_STRUCT fieldID: 1];
      [__intException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__brException_isset) {
    if (__brException != nil) {
      [outProtocol writeFieldBeginWithName: @"brException" type: TType_STRUCT fieldID: 2];
      [__brException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__cfException_isset) {
    if (__cfException != nil) {
      [outProtocol writeFieldBeginWithName: @"cfException" type: TType_STRUCT fieldID: 3];
      [__cfException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CreateAccount_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",intException:"];
  [ms appendFormat: @"%@", __intException];
  [ms appendString: @",brException:"];
  [ms appendFormat: @"%@", __brException];
  [ms appendString: @",cfException:"];
  [ms appendFormat: @"%@", __cfException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTgetAccount_args : NSObject <TBase, NSCoding> {
  LYRTUUID __id;

  BOOL __id_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=id, setter=setId:) LYRTUUID id;
#endif

- (id) init;
- (id) initWithId: (LYRTUUID) id;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTUUID) id;
- (void) setId: (LYRTUUID) id;
#endif
- (BOOL) idIsSet;

@end

@implementation LYRTgetAccount_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithId: (LYRTUUID) id
{
  self = [super init];
  __id = [id retain_stub];
  __id_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"id"])
  {
    __id = [[decoder decodeObjectForKey: @"id"] retain_stub];
    __id_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__id_isset)
  {
    [encoder encodeObject: __id forKey: @"id"];
  }
}

- (void) dealloc
{
  [__id release_stub];
  [super dealloc_stub];
}

- (NSData *) id {
  return [[__id retain_stub] autorelease_stub];
}

- (void) setId: (NSData *) id {
  [id retain_stub];
  [__id release_stub];
  __id = id;
  __id_isset = YES;
}

- (BOOL) idIsSet {
  return __id_isset;
}

- (void) unsetId {
  [__id release_stub];
  __id = nil;
  __id_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getAccount_args"];
  if (__id_isset) {
    if (__id != nil) {
      [outProtocol writeFieldBeginWithName: @"id" type: TType_STRING fieldID: 1];
      [outProtocol writeBinary: __id];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getAccount_args("];
  [ms appendString: @"id:"];
  [ms appendFormat: @"\"%@\"", __id];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTGetAccount_result : NSObject <TBase, NSCoding> {
  LYRTAccount * __success;
  LYRTNotFoundException * __nfException;
  LYRTInternalException * __intException;

  BOOL __success_isset;
  BOOL __nfException_isset;
  BOOL __intException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) LYRTAccount * success;
@property (nonatomic, retain, getter=nfException, setter=setNfException:) LYRTNotFoundException * nfException;
@property (nonatomic, retain, getter=intException, setter=setIntException:) LYRTInternalException * intException;
#endif

- (id) init;
- (id) initWithSuccess: (LYRTAccount *) success nfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTAccount *) success;
- (void) setSuccess: (LYRTAccount *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (LYRTNotFoundException *) nfException;
- (void) setNfException: (LYRTNotFoundException *) nfException;
#endif
- (BOOL) nfExceptionIsSet;

#if !__has_feature(objc_arc)
- (LYRTInternalException *) intException;
- (void) setIntException: (LYRTInternalException *) intException;
#endif
- (BOOL) intExceptionIsSet;

@end

@implementation LYRTGetAccount_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (LYRTAccount *) success nfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __nfException = [nfException retain_stub];
  __nfException_isset = YES;
  __intException = [intException retain_stub];
  __intException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"nfException"])
  {
    __nfException = [[decoder decodeObjectForKey: @"nfException"] retain_stub];
    __nfException_isset = YES;
  }
  if ([decoder containsValueForKey: @"intException"])
  {
    __intException = [[decoder decodeObjectForKey: @"intException"] retain_stub];
    __intException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__nfException_isset)
  {
    [encoder encodeObject: __nfException forKey: @"nfException"];
  }
  if (__intException_isset)
  {
    [encoder encodeObject: __intException forKey: @"intException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__nfException release_stub];
  [__intException release_stub];
  [super dealloc_stub];
}

- (LYRTAccount *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (LYRTAccount *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (LYRTNotFoundException *) nfException {
  return [[__nfException retain_stub] autorelease_stub];
}

- (void) setNfException: (LYRTNotFoundException *) nfException {
  [nfException retain_stub];
  [__nfException release_stub];
  __nfException = nfException;
  __nfException_isset = YES;
}

- (BOOL) nfExceptionIsSet {
  return __nfException_isset;
}

- (void) unsetNfException {
  [__nfException release_stub];
  __nfException = nil;
  __nfException_isset = NO;
}

- (LYRTInternalException *) intException {
  return [[__intException retain_stub] autorelease_stub];
}

- (void) setIntException: (LYRTInternalException *) intException {
  [intException retain_stub];
  [__intException release_stub];
  __intException = intException;
  __intException_isset = YES;
}

- (BOOL) intExceptionIsSet {
  return __intException_isset;
}

- (void) unsetIntException {
  [__intException release_stub];
  __intException = nil;
  __intException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          LYRTAccount *fieldValue = [[LYRTAccount alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTNotFoundException *fieldValue = [[LYRTNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNfException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          LYRTInternalException *fieldValue = [[LYRTInternalException alloc] init];
          [fieldValue read: inProtocol];
          [self setIntException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetAccount_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__nfException_isset) {
    if (__nfException != nil) {
      [outProtocol writeFieldBeginWithName: @"nfException" type: TType_STRUCT fieldID: 1];
      [__nfException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__intException_isset) {
    if (__intException != nil) {
      [outProtocol writeFieldBeginWithName: @"intException" type: TType_STRUCT fieldID: 2];
      [__intException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetAccount_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",nfException:"];
  [ms appendFormat: @"%@", __nfException];
  [ms appendString: @",intException:"];
  [ms appendFormat: @"%@", __intException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTupdateAccount_args : NSObject <TBase, NSCoding> {
  LYRTAccount * __account;

  BOOL __account_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=account, setter=setAccount:) LYRTAccount * account;
#endif

- (id) init;
- (id) initWithAccount: (LYRTAccount *) account;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTAccount *) account;
- (void) setAccount: (LYRTAccount *) account;
#endif
- (BOOL) accountIsSet;

@end

@implementation LYRTupdateAccount_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAccount: (LYRTAccount *) account
{
  self = [super init];
  __account = [account retain_stub];
  __account_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"account"])
  {
    __account = [[decoder decodeObjectForKey: @"account"] retain_stub];
    __account_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__account_isset)
  {
    [encoder encodeObject: __account forKey: @"account"];
  }
}

- (void) dealloc
{
  [__account release_stub];
  [super dealloc_stub];
}

- (LYRTAccount *) account {
  return [[__account retain_stub] autorelease_stub];
}

- (void) setAccount: (LYRTAccount *) account {
  [account retain_stub];
  [__account release_stub];
  __account = account;
  __account_isset = YES;
}

- (BOOL) accountIsSet {
  return __account_isset;
}

- (void) unsetAccount {
  [__account release_stub];
  __account = nil;
  __account_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTAccount *fieldValue = [[LYRTAccount alloc] init];
          [fieldValue read: inProtocol];
          [self setAccount: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"updateAccount_args"];
  if (__account_isset) {
    if (__account != nil) {
      [outProtocol writeFieldBeginWithName: @"account" type: TType_STRUCT fieldID: 1];
      [__account write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"updateAccount_args("];
  [ms appendString: @"account:"];
  [ms appendFormat: @"%@", __account];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTUpdateAccount_result : NSObject <TBase, NSCoding> {
  LYRTNotFoundException * __nfException;
  LYRTInternalException * __intException;
  LYRTConflictException * __cfException;

  BOOL __nfException_isset;
  BOOL __intException_isset;
  BOOL __cfException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=nfException, setter=setNfException:) LYRTNotFoundException * nfException;
@property (nonatomic, retain, getter=intException, setter=setIntException:) LYRTInternalException * intException;
@property (nonatomic, retain, getter=cfException, setter=setCfException:) LYRTConflictException * cfException;
#endif

- (id) init;
- (id) initWithNfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException cfException: (LYRTConflictException *) cfException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTNotFoundException *) nfException;
- (void) setNfException: (LYRTNotFoundException *) nfException;
#endif
- (BOOL) nfExceptionIsSet;

#if !__has_feature(objc_arc)
- (LYRTInternalException *) intException;
- (void) setIntException: (LYRTInternalException *) intException;
#endif
- (BOOL) intExceptionIsSet;

#if !__has_feature(objc_arc)
- (LYRTConflictException *) cfException;
- (void) setCfException: (LYRTConflictException *) cfException;
#endif
- (BOOL) cfExceptionIsSet;

@end

@implementation LYRTUpdateAccount_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithNfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException cfException: (LYRTConflictException *) cfException
{
  self = [super init];
  __nfException = [nfException retain_stub];
  __nfException_isset = YES;
  __intException = [intException retain_stub];
  __intException_isset = YES;
  __cfException = [cfException retain_stub];
  __cfException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"nfException"])
  {
    __nfException = [[decoder decodeObjectForKey: @"nfException"] retain_stub];
    __nfException_isset = YES;
  }
  if ([decoder containsValueForKey: @"intException"])
  {
    __intException = [[decoder decodeObjectForKey: @"intException"] retain_stub];
    __intException_isset = YES;
  }
  if ([decoder containsValueForKey: @"cfException"])
  {
    __cfException = [[decoder decodeObjectForKey: @"cfException"] retain_stub];
    __cfException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__nfException_isset)
  {
    [encoder encodeObject: __nfException forKey: @"nfException"];
  }
  if (__intException_isset)
  {
    [encoder encodeObject: __intException forKey: @"intException"];
  }
  if (__cfException_isset)
  {
    [encoder encodeObject: __cfException forKey: @"cfException"];
  }
}

- (void) dealloc
{
  [__nfException release_stub];
  [__intException release_stub];
  [__cfException release_stub];
  [super dealloc_stub];
}

- (LYRTNotFoundException *) nfException {
  return [[__nfException retain_stub] autorelease_stub];
}

- (void) setNfException: (LYRTNotFoundException *) nfException {
  [nfException retain_stub];
  [__nfException release_stub];
  __nfException = nfException;
  __nfException_isset = YES;
}

- (BOOL) nfExceptionIsSet {
  return __nfException_isset;
}

- (void) unsetNfException {
  [__nfException release_stub];
  __nfException = nil;
  __nfException_isset = NO;
}

- (LYRTInternalException *) intException {
  return [[__intException retain_stub] autorelease_stub];
}

- (void) setIntException: (LYRTInternalException *) intException {
  [intException retain_stub];
  [__intException release_stub];
  __intException = intException;
  __intException_isset = YES;
}

- (BOOL) intExceptionIsSet {
  return __intException_isset;
}

- (void) unsetIntException {
  [__intException release_stub];
  __intException = nil;
  __intException_isset = NO;
}

- (LYRTConflictException *) cfException {
  return [[__cfException retain_stub] autorelease_stub];
}

- (void) setCfException: (LYRTConflictException *) cfException {
  [cfException retain_stub];
  [__cfException release_stub];
  __cfException = cfException;
  __cfException_isset = YES;
}

- (BOOL) cfExceptionIsSet {
  return __cfException_isset;
}

- (void) unsetCfException {
  [__cfException release_stub];
  __cfException = nil;
  __cfException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTNotFoundException *fieldValue = [[LYRTNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNfException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          LYRTInternalException *fieldValue = [[LYRTInternalException alloc] init];
          [fieldValue read: inProtocol];
          [self setIntException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          LYRTConflictException *fieldValue = [[LYRTConflictException alloc] init];
          [fieldValue read: inProtocol];
          [self setCfException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UpdateAccount_result"];

  if (__nfException_isset) {
    if (__nfException != nil) {
      [outProtocol writeFieldBeginWithName: @"nfException" type: TType_STRUCT fieldID: 1];
      [__nfException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__intException_isset) {
    if (__intException != nil) {
      [outProtocol writeFieldBeginWithName: @"intException" type: TType_STRUCT fieldID: 2];
      [__intException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__cfException_isset) {
    if (__cfException != nil) {
      [outProtocol writeFieldBeginWithName: @"cfException" type: TType_STRUCT fieldID: 3];
      [__cfException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UpdateAccount_result("];
  [ms appendString: @"nfException:"];
  [ms appendFormat: @"%@", __nfException];
  [ms appendString: @",intException:"];
  [ms appendFormat: @"%@", __intException];
  [ms appendString: @",cfException:"];
  [ms appendFormat: @"%@", __cfException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTlogin_args : NSObject <TBase, NSCoding> {
  NSString * __email;
  NSString * __password;

  BOOL __email_isset;
  BOOL __password_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=email, setter=setEmail:) NSString * email;
@property (nonatomic, retain, getter=password, setter=setPassword:) NSString * password;
#endif

- (id) init;
- (id) initWithEmail: (NSString *) email password: (NSString *) password;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (NSString *) email;
- (void) setEmail: (NSString *) email;
#endif
- (BOOL) emailIsSet;

#if !__has_feature(objc_arc)
- (NSString *) password;
- (void) setPassword: (NSString *) password;
#endif
- (BOOL) passwordIsSet;

@end

@implementation LYRTlogin_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithEmail: (NSString *) email password: (NSString *) password
{
  self = [super init];
  __email = [email retain_stub];
  __email_isset = YES;
  __password = [password retain_stub];
  __password_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"email"])
  {
    __email = [[decoder decodeObjectForKey: @"email"] retain_stub];
    __email_isset = YES;
  }
  if ([decoder containsValueForKey: @"password"])
  {
    __password = [[decoder decodeObjectForKey: @"password"] retain_stub];
    __password_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__email_isset)
  {
    [encoder encodeObject: __email forKey: @"email"];
  }
  if (__password_isset)
  {
    [encoder encodeObject: __password forKey: @"password"];
  }
}

- (void) dealloc
{
  [__email release_stub];
  [__password release_stub];
  [super dealloc_stub];
}

- (NSString *) email {
  return [[__email retain_stub] autorelease_stub];
}

- (void) setEmail: (NSString *) email {
  [email retain_stub];
  [__email release_stub];
  __email = email;
  __email_isset = YES;
}

- (BOOL) emailIsSet {
  return __email_isset;
}

- (void) unsetEmail {
  [__email release_stub];
  __email = nil;
  __email_isset = NO;
}

- (NSString *) password {
  return [[__password retain_stub] autorelease_stub];
}

- (void) setPassword: (NSString *) password {
  [password retain_stub];
  [__password release_stub];
  __password = password;
  __password_isset = YES;
}

- (BOOL) passwordIsSet {
  return __password_isset;
}

- (void) unsetPassword {
  [__password release_stub];
  __password = nil;
  __password_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setEmail: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setPassword: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"login_args"];
  if (__email_isset) {
    if (__email != nil) {
      [outProtocol writeFieldBeginWithName: @"email" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __email];
      [outProtocol writeFieldEnd];
    }
  }
  if (__password_isset) {
    if (__password != nil) {
      [outProtocol writeFieldBeginWithName: @"password" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __password];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"login_args("];
  [ms appendString: @"email:"];
  [ms appendFormat: @"\"%@\"", __email];
  [ms appendString: @",password:"];
  [ms appendFormat: @"\"%@\"", __password];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTLogin_result : NSObject <TBase, NSCoding> {
  LYRTAccount * __success;
  LYRTNotFoundException * __nfException;
  LYRTUnauthorizedException * __uaException;
  LYRTInternalException * __intException;

  BOOL __success_isset;
  BOOL __nfException_isset;
  BOOL __uaException_isset;
  BOOL __intException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) LYRTAccount * success;
@property (nonatomic, retain, getter=nfException, setter=setNfException:) LYRTNotFoundException * nfException;
@property (nonatomic, retain, getter=uaException, setter=setUaException:) LYRTUnauthorizedException * uaException;
@property (nonatomic, retain, getter=intException, setter=setIntException:) LYRTInternalException * intException;
#endif

- (id) init;
- (id) initWithSuccess: (LYRTAccount *) success nfException: (LYRTNotFoundException *) nfException uaException: (LYRTUnauthorizedException *) uaException intException: (LYRTInternalException *) intException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTAccount *) success;
- (void) setSuccess: (LYRTAccount *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (LYRTNotFoundException *) nfException;
- (void) setNfException: (LYRTNotFoundException *) nfException;
#endif
- (BOOL) nfExceptionIsSet;

#if !__has_feature(objc_arc)
- (LYRTUnauthorizedException *) uaException;
- (void) setUaException: (LYRTUnauthorizedException *) uaException;
#endif
- (BOOL) uaExceptionIsSet;

#if !__has_feature(objc_arc)
- (LYRTInternalException *) intException;
- (void) setIntException: (LYRTInternalException *) intException;
#endif
- (BOOL) intExceptionIsSet;

@end

@implementation LYRTLogin_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (LYRTAccount *) success nfException: (LYRTNotFoundException *) nfException uaException: (LYRTUnauthorizedException *) uaException intException: (LYRTInternalException *) intException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __nfException = [nfException retain_stub];
  __nfException_isset = YES;
  __uaException = [uaException retain_stub];
  __uaException_isset = YES;
  __intException = [intException retain_stub];
  __intException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"nfException"])
  {
    __nfException = [[decoder decodeObjectForKey: @"nfException"] retain_stub];
    __nfException_isset = YES;
  }
  if ([decoder containsValueForKey: @"uaException"])
  {
    __uaException = [[decoder decodeObjectForKey: @"uaException"] retain_stub];
    __uaException_isset = YES;
  }
  if ([decoder containsValueForKey: @"intException"])
  {
    __intException = [[decoder decodeObjectForKey: @"intException"] retain_stub];
    __intException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__nfException_isset)
  {
    [encoder encodeObject: __nfException forKey: @"nfException"];
  }
  if (__uaException_isset)
  {
    [encoder encodeObject: __uaException forKey: @"uaException"];
  }
  if (__intException_isset)
  {
    [encoder encodeObject: __intException forKey: @"intException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__nfException release_stub];
  [__uaException release_stub];
  [__intException release_stub];
  [super dealloc_stub];
}

- (LYRTAccount *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (LYRTAccount *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (LYRTNotFoundException *) nfException {
  return [[__nfException retain_stub] autorelease_stub];
}

- (void) setNfException: (LYRTNotFoundException *) nfException {
  [nfException retain_stub];
  [__nfException release_stub];
  __nfException = nfException;
  __nfException_isset = YES;
}

- (BOOL) nfExceptionIsSet {
  return __nfException_isset;
}

- (void) unsetNfException {
  [__nfException release_stub];
  __nfException = nil;
  __nfException_isset = NO;
}

- (LYRTUnauthorizedException *) uaException {
  return [[__uaException retain_stub] autorelease_stub];
}

- (void) setUaException: (LYRTUnauthorizedException *) uaException {
  [uaException retain_stub];
  [__uaException release_stub];
  __uaException = uaException;
  __uaException_isset = YES;
}

- (BOOL) uaExceptionIsSet {
  return __uaException_isset;
}

- (void) unsetUaException {
  [__uaException release_stub];
  __uaException = nil;
  __uaException_isset = NO;
}

- (LYRTInternalException *) intException {
  return [[__intException retain_stub] autorelease_stub];
}

- (void) setIntException: (LYRTInternalException *) intException {
  [intException retain_stub];
  [__intException release_stub];
  __intException = intException;
  __intException_isset = YES;
}

- (BOOL) intExceptionIsSet {
  return __intException_isset;
}

- (void) unsetIntException {
  [__intException release_stub];
  __intException = nil;
  __intException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          LYRTAccount *fieldValue = [[LYRTAccount alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTNotFoundException *fieldValue = [[LYRTNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNfException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          LYRTUnauthorizedException *fieldValue = [[LYRTUnauthorizedException alloc] init];
          [fieldValue read: inProtocol];
          [self setUaException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          LYRTInternalException *fieldValue = [[LYRTInternalException alloc] init];
          [fieldValue read: inProtocol];
          [self setIntException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Login_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__nfException_isset) {
    if (__nfException != nil) {
      [outProtocol writeFieldBeginWithName: @"nfException" type: TType_STRUCT fieldID: 1];
      [__nfException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__uaException_isset) {
    if (__uaException != nil) {
      [outProtocol writeFieldBeginWithName: @"uaException" type: TType_STRUCT fieldID: 2];
      [__uaException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__intException_isset) {
    if (__intException != nil) {
      [outProtocol writeFieldBeginWithName: @"intException" type: TType_STRUCT fieldID: 3];
      [__intException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Login_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",nfException:"];
  [ms appendFormat: @"%@", __nfException];
  [ms appendString: @",uaException:"];
  [ms appendFormat: @"%@", __uaException];
  [ms appendString: @",intException:"];
  [ms appendFormat: @"%@", __intException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTresetPassword_args : NSObject <TBase, NSCoding> {
  LYRTUUID __id;
  NSString * __old_password;
  NSString * __new_password;

  BOOL __id_isset;
  BOOL __old_password_isset;
  BOOL __new_password_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=id, setter=setId:) LYRTUUID id;
@property (nonatomic, retain, getter=old_password, setter=setOld_password:) NSString * old_password;
@property (nonatomic, retain, getter=new_password, setter=setNew_password:) NSString * new_password;
#endif

- (id) init;
- (id) initWithId: (LYRTUUID) id old_password: (NSString *) old_password new_password: (NSString *) new_password;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTUUID) id;
- (void) setId: (LYRTUUID) id;
#endif
- (BOOL) idIsSet;

#if !__has_feature(objc_arc)
- (NSString *) old_password;
- (void) setOld_password: (NSString *) old_password;
#endif
- (BOOL) old_passwordIsSet;

#if !__has_feature(objc_arc)
- (NSString *) new_password;
- (void) setNew_password: (NSString *) new_password;
#endif
- (BOOL) new_passwordIsSet;

@end

@implementation LYRTresetPassword_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithId: (LYRTUUID) id old_password: (NSString *) old_password new_password: (NSString *) new_password
{
  self = [super init];
  __id = [id retain_stub];
  __id_isset = YES;
  __old_password = [old_password retain_stub];
  __old_password_isset = YES;
  __new_password = [new_password retain_stub];
  __new_password_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"id"])
  {
    __id = [[decoder decodeObjectForKey: @"id"] retain_stub];
    __id_isset = YES;
  }
  if ([decoder containsValueForKey: @"old_password"])
  {
    __old_password = [[decoder decodeObjectForKey: @"old_password"] retain_stub];
    __old_password_isset = YES;
  }
  if ([decoder containsValueForKey: @"new_password"])
  {
    __new_password = [[decoder decodeObjectForKey: @"new_password"] retain_stub];
    __new_password_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__id_isset)
  {
    [encoder encodeObject: __id forKey: @"id"];
  }
  if (__old_password_isset)
  {
    [encoder encodeObject: __old_password forKey: @"old_password"];
  }
  if (__new_password_isset)
  {
    [encoder encodeObject: __new_password forKey: @"new_password"];
  }
}

- (void) dealloc
{
  [__id release_stub];
  [__old_password release_stub];
  [__new_password release_stub];
  [super dealloc_stub];
}

- (NSData *) id {
  return [[__id retain_stub] autorelease_stub];
}

- (void) setId: (NSData *) id {
  [id retain_stub];
  [__id release_stub];
  __id = id;
  __id_isset = YES;
}

- (BOOL) idIsSet {
  return __id_isset;
}

- (void) unsetId {
  [__id release_stub];
  __id = nil;
  __id_isset = NO;
}

- (NSString *) old_password {
  return [[__old_password retain_stub] autorelease_stub];
}

- (void) setOld_password: (NSString *) old_password {
  [old_password retain_stub];
  [__old_password release_stub];
  __old_password = old_password;
  __old_password_isset = YES;
}

- (BOOL) old_passwordIsSet {
  return __old_password_isset;
}

- (void) unsetOld_password {
  [__old_password release_stub];
  __old_password = nil;
  __old_password_isset = NO;
}

- (NSString *) new_password {
  return [[__new_password retain_stub] autorelease_stub];
}

- (void) setNew_password: (NSString *) new_password {
  [new_password retain_stub];
  [__new_password release_stub];
  __new_password = new_password;
  __new_password_isset = YES;
}

- (BOOL) new_passwordIsSet {
  return __new_password_isset;
}

- (void) unsetNew_password {
  [__new_password release_stub];
  __new_password = nil;
  __new_password_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setOld_password: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNew_password: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"resetPassword_args"];
  if (__id_isset) {
    if (__id != nil) {
      [outProtocol writeFieldBeginWithName: @"id" type: TType_STRING fieldID: 1];
      [outProtocol writeBinary: __id];
      [outProtocol writeFieldEnd];
    }
  }
  if (__old_password_isset) {
    if (__old_password != nil) {
      [outProtocol writeFieldBeginWithName: @"old_password" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __old_password];
      [outProtocol writeFieldEnd];
    }
  }
  if (__new_password_isset) {
    if (__new_password != nil) {
      [outProtocol writeFieldBeginWithName: @"new_password" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __new_password];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"resetPassword_args("];
  [ms appendString: @"id:"];
  [ms appendFormat: @"\"%@\"", __id];
  [ms appendString: @",old_password:"];
  [ms appendFormat: @"\"%@\"", __old_password];
  [ms appendString: @",new_password:"];
  [ms appendFormat: @"\"%@\"", __new_password];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTResetPassword_result : NSObject <TBase, NSCoding> {
  LYRTNotFoundException * __nfException;
  LYRTUnauthorizedException * __uaException;
  LYRTInternalException * __intException;

  BOOL __nfException_isset;
  BOOL __uaException_isset;
  BOOL __intException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=nfException, setter=setNfException:) LYRTNotFoundException * nfException;
@property (nonatomic, retain, getter=uaException, setter=setUaException:) LYRTUnauthorizedException * uaException;
@property (nonatomic, retain, getter=intException, setter=setIntException:) LYRTInternalException * intException;
#endif

- (id) init;
- (id) initWithNfException: (LYRTNotFoundException *) nfException uaException: (LYRTUnauthorizedException *) uaException intException: (LYRTInternalException *) intException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTNotFoundException *) nfException;
- (void) setNfException: (LYRTNotFoundException *) nfException;
#endif
- (BOOL) nfExceptionIsSet;

#if !__has_feature(objc_arc)
- (LYRTUnauthorizedException *) uaException;
- (void) setUaException: (LYRTUnauthorizedException *) uaException;
#endif
- (BOOL) uaExceptionIsSet;

#if !__has_feature(objc_arc)
- (LYRTInternalException *) intException;
- (void) setIntException: (LYRTInternalException *) intException;
#endif
- (BOOL) intExceptionIsSet;

@end

@implementation LYRTResetPassword_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithNfException: (LYRTNotFoundException *) nfException uaException: (LYRTUnauthorizedException *) uaException intException: (LYRTInternalException *) intException
{
  self = [super init];
  __nfException = [nfException retain_stub];
  __nfException_isset = YES;
  __uaException = [uaException retain_stub];
  __uaException_isset = YES;
  __intException = [intException retain_stub];
  __intException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"nfException"])
  {
    __nfException = [[decoder decodeObjectForKey: @"nfException"] retain_stub];
    __nfException_isset = YES;
  }
  if ([decoder containsValueForKey: @"uaException"])
  {
    __uaException = [[decoder decodeObjectForKey: @"uaException"] retain_stub];
    __uaException_isset = YES;
  }
  if ([decoder containsValueForKey: @"intException"])
  {
    __intException = [[decoder decodeObjectForKey: @"intException"] retain_stub];
    __intException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__nfException_isset)
  {
    [encoder encodeObject: __nfException forKey: @"nfException"];
  }
  if (__uaException_isset)
  {
    [encoder encodeObject: __uaException forKey: @"uaException"];
  }
  if (__intException_isset)
  {
    [encoder encodeObject: __intException forKey: @"intException"];
  }
}

- (void) dealloc
{
  [__nfException release_stub];
  [__uaException release_stub];
  [__intException release_stub];
  [super dealloc_stub];
}

- (LYRTNotFoundException *) nfException {
  return [[__nfException retain_stub] autorelease_stub];
}

- (void) setNfException: (LYRTNotFoundException *) nfException {
  [nfException retain_stub];
  [__nfException release_stub];
  __nfException = nfException;
  __nfException_isset = YES;
}

- (BOOL) nfExceptionIsSet {
  return __nfException_isset;
}

- (void) unsetNfException {
  [__nfException release_stub];
  __nfException = nil;
  __nfException_isset = NO;
}

- (LYRTUnauthorizedException *) uaException {
  return [[__uaException retain_stub] autorelease_stub];
}

- (void) setUaException: (LYRTUnauthorizedException *) uaException {
  [uaException retain_stub];
  [__uaException release_stub];
  __uaException = uaException;
  __uaException_isset = YES;
}

- (BOOL) uaExceptionIsSet {
  return __uaException_isset;
}

- (void) unsetUaException {
  [__uaException release_stub];
  __uaException = nil;
  __uaException_isset = NO;
}

- (LYRTInternalException *) intException {
  return [[__intException retain_stub] autorelease_stub];
}

- (void) setIntException: (LYRTInternalException *) intException {
  [intException retain_stub];
  [__intException release_stub];
  __intException = intException;
  __intException_isset = YES;
}

- (BOOL) intExceptionIsSet {
  return __intException_isset;
}

- (void) unsetIntException {
  [__intException release_stub];
  __intException = nil;
  __intException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTNotFoundException *fieldValue = [[LYRTNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNfException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          LYRTUnauthorizedException *fieldValue = [[LYRTUnauthorizedException alloc] init];
          [fieldValue read: inProtocol];
          [self setUaException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          LYRTInternalException *fieldValue = [[LYRTInternalException alloc] init];
          [fieldValue read: inProtocol];
          [self setIntException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ResetPassword_result"];

  if (__nfException_isset) {
    if (__nfException != nil) {
      [outProtocol writeFieldBeginWithName: @"nfException" type: TType_STRUCT fieldID: 1];
      [__nfException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__uaException_isset) {
    if (__uaException != nil) {
      [outProtocol writeFieldBeginWithName: @"uaException" type: TType_STRUCT fieldID: 2];
      [__uaException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__intException_isset) {
    if (__intException != nil) {
      [outProtocol writeFieldBeginWithName: @"intException" type: TType_STRUCT fieldID: 3];
      [__intException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ResetPassword_result("];
  [ms appendString: @"nfException:"];
  [ms appendFormat: @"%@", __nfException];
  [ms appendString: @",uaException:"];
  [ms appendFormat: @"%@", __uaException];
  [ms appendString: @",intException:"];
  [ms appendFormat: @"%@", __intException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTforceResetPassword_args : NSObject <TBase, NSCoding> {
  LYRTUUID __id;
  NSString * __new_password;

  BOOL __id_isset;
  BOOL __new_password_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=id, setter=setId:) LYRTUUID id;
@property (nonatomic, retain, getter=new_password, setter=setNew_password:) NSString * new_password;
#endif

- (id) init;
- (id) initWithId: (LYRTUUID) id new_password: (NSString *) new_password;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTUUID) id;
- (void) setId: (LYRTUUID) id;
#endif
- (BOOL) idIsSet;

#if !__has_feature(objc_arc)
- (NSString *) new_password;
- (void) setNew_password: (NSString *) new_password;
#endif
- (BOOL) new_passwordIsSet;

@end

@implementation LYRTforceResetPassword_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithId: (LYRTUUID) id new_password: (NSString *) new_password
{
  self = [super init];
  __id = [id retain_stub];
  __id_isset = YES;
  __new_password = [new_password retain_stub];
  __new_password_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"id"])
  {
    __id = [[decoder decodeObjectForKey: @"id"] retain_stub];
    __id_isset = YES;
  }
  if ([decoder containsValueForKey: @"new_password"])
  {
    __new_password = [[decoder decodeObjectForKey: @"new_password"] retain_stub];
    __new_password_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__id_isset)
  {
    [encoder encodeObject: __id forKey: @"id"];
  }
  if (__new_password_isset)
  {
    [encoder encodeObject: __new_password forKey: @"new_password"];
  }
}

- (void) dealloc
{
  [__id release_stub];
  [__new_password release_stub];
  [super dealloc_stub];
}

- (NSData *) id {
  return [[__id retain_stub] autorelease_stub];
}

- (void) setId: (NSData *) id {
  [id retain_stub];
  [__id release_stub];
  __id = id;
  __id_isset = YES;
}

- (BOOL) idIsSet {
  return __id_isset;
}

- (void) unsetId {
  [__id release_stub];
  __id = nil;
  __id_isset = NO;
}

- (NSString *) new_password {
  return [[__new_password retain_stub] autorelease_stub];
}

- (void) setNew_password: (NSString *) new_password {
  [new_password retain_stub];
  [__new_password release_stub];
  __new_password = new_password;
  __new_password_isset = YES;
}

- (BOOL) new_passwordIsSet {
  return __new_password_isset;
}

- (void) unsetNew_password {
  [__new_password release_stub];
  __new_password = nil;
  __new_password_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNew_password: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"forceResetPassword_args"];
  if (__id_isset) {
    if (__id != nil) {
      [outProtocol writeFieldBeginWithName: @"id" type: TType_STRING fieldID: 1];
      [outProtocol writeBinary: __id];
      [outProtocol writeFieldEnd];
    }
  }
  if (__new_password_isset) {
    if (__new_password != nil) {
      [outProtocol writeFieldBeginWithName: @"new_password" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __new_password];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"forceResetPassword_args("];
  [ms appendString: @"id:"];
  [ms appendFormat: @"\"%@\"", __id];
  [ms appendString: @",new_password:"];
  [ms appendFormat: @"\"%@\"", __new_password];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTForceResetPassword_result : NSObject <TBase, NSCoding> {
  LYRTNotFoundException * __nfException;
  LYRTUnauthorizedException * __uaException;
  LYRTInternalException * __intException;

  BOOL __nfException_isset;
  BOOL __uaException_isset;
  BOOL __intException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=nfException, setter=setNfException:) LYRTNotFoundException * nfException;
@property (nonatomic, retain, getter=uaException, setter=setUaException:) LYRTUnauthorizedException * uaException;
@property (nonatomic, retain, getter=intException, setter=setIntException:) LYRTInternalException * intException;
#endif

- (id) init;
- (id) initWithNfException: (LYRTNotFoundException *) nfException uaException: (LYRTUnauthorizedException *) uaException intException: (LYRTInternalException *) intException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTNotFoundException *) nfException;
- (void) setNfException: (LYRTNotFoundException *) nfException;
#endif
- (BOOL) nfExceptionIsSet;

#if !__has_feature(objc_arc)
- (LYRTUnauthorizedException *) uaException;
- (void) setUaException: (LYRTUnauthorizedException *) uaException;
#endif
- (BOOL) uaExceptionIsSet;

#if !__has_feature(objc_arc)
- (LYRTInternalException *) intException;
- (void) setIntException: (LYRTInternalException *) intException;
#endif
- (BOOL) intExceptionIsSet;

@end

@implementation LYRTForceResetPassword_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithNfException: (LYRTNotFoundException *) nfException uaException: (LYRTUnauthorizedException *) uaException intException: (LYRTInternalException *) intException
{
  self = [super init];
  __nfException = [nfException retain_stub];
  __nfException_isset = YES;
  __uaException = [uaException retain_stub];
  __uaException_isset = YES;
  __intException = [intException retain_stub];
  __intException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"nfException"])
  {
    __nfException = [[decoder decodeObjectForKey: @"nfException"] retain_stub];
    __nfException_isset = YES;
  }
  if ([decoder containsValueForKey: @"uaException"])
  {
    __uaException = [[decoder decodeObjectForKey: @"uaException"] retain_stub];
    __uaException_isset = YES;
  }
  if ([decoder containsValueForKey: @"intException"])
  {
    __intException = [[decoder decodeObjectForKey: @"intException"] retain_stub];
    __intException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__nfException_isset)
  {
    [encoder encodeObject: __nfException forKey: @"nfException"];
  }
  if (__uaException_isset)
  {
    [encoder encodeObject: __uaException forKey: @"uaException"];
  }
  if (__intException_isset)
  {
    [encoder encodeObject: __intException forKey: @"intException"];
  }
}

- (void) dealloc
{
  [__nfException release_stub];
  [__uaException release_stub];
  [__intException release_stub];
  [super dealloc_stub];
}

- (LYRTNotFoundException *) nfException {
  return [[__nfException retain_stub] autorelease_stub];
}

- (void) setNfException: (LYRTNotFoundException *) nfException {
  [nfException retain_stub];
  [__nfException release_stub];
  __nfException = nfException;
  __nfException_isset = YES;
}

- (BOOL) nfExceptionIsSet {
  return __nfException_isset;
}

- (void) unsetNfException {
  [__nfException release_stub];
  __nfException = nil;
  __nfException_isset = NO;
}

- (LYRTUnauthorizedException *) uaException {
  return [[__uaException retain_stub] autorelease_stub];
}

- (void) setUaException: (LYRTUnauthorizedException *) uaException {
  [uaException retain_stub];
  [__uaException release_stub];
  __uaException = uaException;
  __uaException_isset = YES;
}

- (BOOL) uaExceptionIsSet {
  return __uaException_isset;
}

- (void) unsetUaException {
  [__uaException release_stub];
  __uaException = nil;
  __uaException_isset = NO;
}

- (LYRTInternalException *) intException {
  return [[__intException retain_stub] autorelease_stub];
}

- (void) setIntException: (LYRTInternalException *) intException {
  [intException retain_stub];
  [__intException release_stub];
  __intException = intException;
  __intException_isset = YES;
}

- (BOOL) intExceptionIsSet {
  return __intException_isset;
}

- (void) unsetIntException {
  [__intException release_stub];
  __intException = nil;
  __intException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTNotFoundException *fieldValue = [[LYRTNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNfException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          LYRTUnauthorizedException *fieldValue = [[LYRTUnauthorizedException alloc] init];
          [fieldValue read: inProtocol];
          [self setUaException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          LYRTInternalException *fieldValue = [[LYRTInternalException alloc] init];
          [fieldValue read: inProtocol];
          [self setIntException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ForceResetPassword_result"];

  if (__nfException_isset) {
    if (__nfException != nil) {
      [outProtocol writeFieldBeginWithName: @"nfException" type: TType_STRUCT fieldID: 1];
      [__nfException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__uaException_isset) {
    if (__uaException != nil) {
      [outProtocol writeFieldBeginWithName: @"uaException" type: TType_STRUCT fieldID: 2];
      [__uaException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__intException_isset) {
    if (__intException != nil) {
      [outProtocol writeFieldBeginWithName: @"intException" type: TType_STRUCT fieldID: 3];
      [__intException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ForceResetPassword_result("];
  [ms appendString: @"nfException:"];
  [ms appendFormat: @"%@", __nfException];
  [ms appendString: @",uaException:"];
  [ms appendFormat: @"%@", __uaException];
  [ms appendString: @",intException:"];
  [ms appendFormat: @"%@", __intException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTgetAccountByEmail_args : NSObject <TBase, NSCoding> {
  NSString * __email;

  BOOL __email_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=email, setter=setEmail:) NSString * email;
#endif

- (id) init;
- (id) initWithEmail: (NSString *) email;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (NSString *) email;
- (void) setEmail: (NSString *) email;
#endif
- (BOOL) emailIsSet;

@end

@implementation LYRTgetAccountByEmail_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithEmail: (NSString *) email
{
  self = [super init];
  __email = [email retain_stub];
  __email_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"email"])
  {
    __email = [[decoder decodeObjectForKey: @"email"] retain_stub];
    __email_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__email_isset)
  {
    [encoder encodeObject: __email forKey: @"email"];
  }
}

- (void) dealloc
{
  [__email release_stub];
  [super dealloc_stub];
}

- (NSString *) email {
  return [[__email retain_stub] autorelease_stub];
}

- (void) setEmail: (NSString *) email {
  [email retain_stub];
  [__email release_stub];
  __email = email;
  __email_isset = YES;
}

- (BOOL) emailIsSet {
  return __email_isset;
}

- (void) unsetEmail {
  [__email release_stub];
  __email = nil;
  __email_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setEmail: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getAccountByEmail_args"];
  if (__email_isset) {
    if (__email != nil) {
      [outProtocol writeFieldBeginWithName: @"email" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __email];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getAccountByEmail_args("];
  [ms appendString: @"email:"];
  [ms appendFormat: @"\"%@\"", __email];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTGetAccountByEmail_result : NSObject <TBase, NSCoding> {
  LYRTAccount * __success;
  LYRTNotFoundException * __nfException;
  LYRTInternalException * __intException;

  BOOL __success_isset;
  BOOL __nfException_isset;
  BOOL __intException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) LYRTAccount * success;
@property (nonatomic, retain, getter=nfException, setter=setNfException:) LYRTNotFoundException * nfException;
@property (nonatomic, retain, getter=intException, setter=setIntException:) LYRTInternalException * intException;
#endif

- (id) init;
- (id) initWithSuccess: (LYRTAccount *) success nfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTAccount *) success;
- (void) setSuccess: (LYRTAccount *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (LYRTNotFoundException *) nfException;
- (void) setNfException: (LYRTNotFoundException *) nfException;
#endif
- (BOOL) nfExceptionIsSet;

#if !__has_feature(objc_arc)
- (LYRTInternalException *) intException;
- (void) setIntException: (LYRTInternalException *) intException;
#endif
- (BOOL) intExceptionIsSet;

@end

@implementation LYRTGetAccountByEmail_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (LYRTAccount *) success nfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __nfException = [nfException retain_stub];
  __nfException_isset = YES;
  __intException = [intException retain_stub];
  __intException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"nfException"])
  {
    __nfException = [[decoder decodeObjectForKey: @"nfException"] retain_stub];
    __nfException_isset = YES;
  }
  if ([decoder containsValueForKey: @"intException"])
  {
    __intException = [[decoder decodeObjectForKey: @"intException"] retain_stub];
    __intException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__nfException_isset)
  {
    [encoder encodeObject: __nfException forKey: @"nfException"];
  }
  if (__intException_isset)
  {
    [encoder encodeObject: __intException forKey: @"intException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__nfException release_stub];
  [__intException release_stub];
  [super dealloc_stub];
}

- (LYRTAccount *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (LYRTAccount *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (LYRTNotFoundException *) nfException {
  return [[__nfException retain_stub] autorelease_stub];
}

- (void) setNfException: (LYRTNotFoundException *) nfException {
  [nfException retain_stub];
  [__nfException release_stub];
  __nfException = nfException;
  __nfException_isset = YES;
}

- (BOOL) nfExceptionIsSet {
  return __nfException_isset;
}

- (void) unsetNfException {
  [__nfException release_stub];
  __nfException = nil;
  __nfException_isset = NO;
}

- (LYRTInternalException *) intException {
  return [[__intException retain_stub] autorelease_stub];
}

- (void) setIntException: (LYRTInternalException *) intException {
  [intException retain_stub];
  [__intException release_stub];
  __intException = intException;
  __intException_isset = YES;
}

- (BOOL) intExceptionIsSet {
  return __intException_isset;
}

- (void) unsetIntException {
  [__intException release_stub];
  __intException = nil;
  __intException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          LYRTAccount *fieldValue = [[LYRTAccount alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTNotFoundException *fieldValue = [[LYRTNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNfException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          LYRTInternalException *fieldValue = [[LYRTInternalException alloc] init];
          [fieldValue read: inProtocol];
          [self setIntException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetAccountByEmail_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__nfException_isset) {
    if (__nfException != nil) {
      [outProtocol writeFieldBeginWithName: @"nfException" type: TType_STRUCT fieldID: 1];
      [__nfException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__intException_isset) {
    if (__intException != nil) {
      [outProtocol writeFieldBeginWithName: @"intException" type: TType_STRUCT fieldID: 2];
      [__intException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetAccountByEmail_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",nfException:"];
  [ms appendFormat: @"%@", __nfException];
  [ms appendString: @",intException:"];
  [ms appendFormat: @"%@", __intException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTgetAllAccounts_args : NSObject <TBase, NSCoding> {
}

- (id) init;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

@end

@implementation LYRTgetAllAccounts_args

- (id) init
{
  self = [super init];
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getAllAccounts_args"];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getAllAccounts_args("];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTGetAllAccounts_result : NSObject <TBase, NSCoding> {
  LYRTAccounts __success;
  LYRTNotFoundException * __nfException;
  LYRTInternalException * __intException;

  BOOL __success_isset;
  BOOL __nfException_isset;
  BOOL __intException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) LYRTAccounts success;
@property (nonatomic, retain, getter=nfException, setter=setNfException:) LYRTNotFoundException * nfException;
@property (nonatomic, retain, getter=intException, setter=setIntException:) LYRTInternalException * intException;
#endif

- (id) init;
- (id) initWithSuccess: (LYRTAccounts) success nfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTAccounts) success;
- (void) setSuccess: (LYRTAccounts) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (LYRTNotFoundException *) nfException;
- (void) setNfException: (LYRTNotFoundException *) nfException;
#endif
- (BOOL) nfExceptionIsSet;

#if !__has_feature(objc_arc)
- (LYRTInternalException *) intException;
- (void) setIntException: (LYRTInternalException *) intException;
#endif
- (BOOL) intExceptionIsSet;

@end

@implementation LYRTGetAllAccounts_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (LYRTAccounts) success nfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __nfException = [nfException retain_stub];
  __nfException_isset = YES;
  __intException = [intException retain_stub];
  __intException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"nfException"])
  {
    __nfException = [[decoder decodeObjectForKey: @"nfException"] retain_stub];
    __nfException_isset = YES;
  }
  if ([decoder containsValueForKey: @"intException"])
  {
    __intException = [[decoder decodeObjectForKey: @"intException"] retain_stub];
    __intException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__nfException_isset)
  {
    [encoder encodeObject: __nfException forKey: @"nfException"];
  }
  if (__intException_isset)
  {
    [encoder encodeObject: __intException forKey: @"intException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__nfException release_stub];
  [__intException release_stub];
  [super dealloc_stub];
}

- (NSMutableArray *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (NSMutableArray *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (LYRTNotFoundException *) nfException {
  return [[__nfException retain_stub] autorelease_stub];
}

- (void) setNfException: (LYRTNotFoundException *) nfException {
  [nfException retain_stub];
  [__nfException release_stub];
  __nfException = nfException;
  __nfException_isset = YES;
}

- (BOOL) nfExceptionIsSet {
  return __nfException_isset;
}

- (void) unsetNfException {
  [__nfException release_stub];
  __nfException = nil;
  __nfException_isset = NO;
}

- (LYRTInternalException *) intException {
  return [[__intException retain_stub] autorelease_stub];
}

- (void) setIntException: (LYRTInternalException *) intException {
  [intException retain_stub];
  [__intException release_stub];
  __intException = intException;
  __intException_isset = YES;
}

- (BOOL) intExceptionIsSet {
  return __intException_isset;
}

- (void) unsetIntException {
  [__intException release_stub];
  __intException = nil;
  __intException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size5;
          [inProtocol readListBeginReturningElementType: NULL size: &_size5];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size5];
          int _i6;
          for (_i6 = 0; _i6 < _size5; ++_i6)
          {
            LYRTAccount *_elem7 = [[LYRTAccount alloc] init];
            [_elem7 read: inProtocol];
            [fieldValue addObject: _elem7];
            [_elem7 release_stub];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTNotFoundException *fieldValue = [[LYRTNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNfException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          LYRTInternalException *fieldValue = [[LYRTInternalException alloc] init];
          [fieldValue read: inProtocol];
          [self setIntException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetAllAccounts_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        int i9;
        for (i9 = 0; i9 < [__success count]; i9++)
        {
          [[__success objectAtIndex: i9] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__nfException_isset) {
    if (__nfException != nil) {
      [outProtocol writeFieldBeginWithName: @"nfException" type: TType_STRUCT fieldID: 1];
      [__nfException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__intException_isset) {
    if (__intException != nil) {
      [outProtocol writeFieldBeginWithName: @"intException" type: TType_STRUCT fieldID: 2];
      [__intException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetAllAccounts_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",nfException:"];
  [ms appendFormat: @"%@", __nfException];
  [ms appendString: @",intException:"];
  [ms appendFormat: @"%@", __intException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTgetAccountWithApps_args : NSObject <TBase, NSCoding> {
  LYRTUUID __id;

  BOOL __id_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=id, setter=setId:) LYRTUUID id;
#endif

- (id) init;
- (id) initWithId: (LYRTUUID) id;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTUUID) id;
- (void) setId: (LYRTUUID) id;
#endif
- (BOOL) idIsSet;

@end

@implementation LYRTgetAccountWithApps_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithId: (LYRTUUID) id
{
  self = [super init];
  __id = [id retain_stub];
  __id_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"id"])
  {
    __id = [[decoder decodeObjectForKey: @"id"] retain_stub];
    __id_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__id_isset)
  {
    [encoder encodeObject: __id forKey: @"id"];
  }
}

- (void) dealloc
{
  [__id release_stub];
  [super dealloc_stub];
}

- (NSData *) id {
  return [[__id retain_stub] autorelease_stub];
}

- (void) setId: (NSData *) id {
  [id retain_stub];
  [__id release_stub];
  __id = id;
  __id_isset = YES;
}

- (BOOL) idIsSet {
  return __id_isset;
}

- (void) unsetId {
  [__id release_stub];
  __id = nil;
  __id_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getAccountWithApps_args"];
  if (__id_isset) {
    if (__id != nil) {
      [outProtocol writeFieldBeginWithName: @"id" type: TType_STRING fieldID: 1];
      [outProtocol writeBinary: __id];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getAccountWithApps_args("];
  [ms appendString: @"id:"];
  [ms appendFormat: @"\"%@\"", __id];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTGetAccountWithApps_result : NSObject <TBase, NSCoding> {
  LYRTAccountApps * __success;
  LYRTNotFoundException * __nfException;
  LYRTInternalException * __intException;

  BOOL __success_isset;
  BOOL __nfException_isset;
  BOOL __intException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) LYRTAccountApps * success;
@property (nonatomic, retain, getter=nfException, setter=setNfException:) LYRTNotFoundException * nfException;
@property (nonatomic, retain, getter=intException, setter=setIntException:) LYRTInternalException * intException;
#endif

- (id) init;
- (id) initWithSuccess: (LYRTAccountApps *) success nfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTAccountApps *) success;
- (void) setSuccess: (LYRTAccountApps *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (LYRTNotFoundException *) nfException;
- (void) setNfException: (LYRTNotFoundException *) nfException;
#endif
- (BOOL) nfExceptionIsSet;

#if !__has_feature(objc_arc)
- (LYRTInternalException *) intException;
- (void) setIntException: (LYRTInternalException *) intException;
#endif
- (BOOL) intExceptionIsSet;

@end

@implementation LYRTGetAccountWithApps_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (LYRTAccountApps *) success nfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __nfException = [nfException retain_stub];
  __nfException_isset = YES;
  __intException = [intException retain_stub];
  __intException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"nfException"])
  {
    __nfException = [[decoder decodeObjectForKey: @"nfException"] retain_stub];
    __nfException_isset = YES;
  }
  if ([decoder containsValueForKey: @"intException"])
  {
    __intException = [[decoder decodeObjectForKey: @"intException"] retain_stub];
    __intException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__nfException_isset)
  {
    [encoder encodeObject: __nfException forKey: @"nfException"];
  }
  if (__intException_isset)
  {
    [encoder encodeObject: __intException forKey: @"intException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__nfException release_stub];
  [__intException release_stub];
  [super dealloc_stub];
}

- (LYRTAccountApps *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (LYRTAccountApps *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (LYRTNotFoundException *) nfException {
  return [[__nfException retain_stub] autorelease_stub];
}

- (void) setNfException: (LYRTNotFoundException *) nfException {
  [nfException retain_stub];
  [__nfException release_stub];
  __nfException = nfException;
  __nfException_isset = YES;
}

- (BOOL) nfExceptionIsSet {
  return __nfException_isset;
}

- (void) unsetNfException {
  [__nfException release_stub];
  __nfException = nil;
  __nfException_isset = NO;
}

- (LYRTInternalException *) intException {
  return [[__intException retain_stub] autorelease_stub];
}

- (void) setIntException: (LYRTInternalException *) intException {
  [intException retain_stub];
  [__intException release_stub];
  __intException = intException;
  __intException_isset = YES;
}

- (BOOL) intExceptionIsSet {
  return __intException_isset;
}

- (void) unsetIntException {
  [__intException release_stub];
  __intException = nil;
  __intException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          LYRTAccountApps *fieldValue = [[LYRTAccountApps alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTNotFoundException *fieldValue = [[LYRTNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNfException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          LYRTInternalException *fieldValue = [[LYRTInternalException alloc] init];
          [fieldValue read: inProtocol];
          [self setIntException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetAccountWithApps_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__nfException_isset) {
    if (__nfException != nil) {
      [outProtocol writeFieldBeginWithName: @"nfException" type: TType_STRUCT fieldID: 1];
      [__nfException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__intException_isset) {
    if (__intException != nil) {
      [outProtocol writeFieldBeginWithName: @"intException" type: TType_STRUCT fieldID: 2];
      [__intException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetAccountWithApps_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",nfException:"];
  [ms appendFormat: @"%@", __nfException];
  [ms appendString: @",intException:"];
  [ms appendFormat: @"%@", __intException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTgetAccountsWithApps_args : NSObject <TBase, NSCoding> {
}

- (id) init;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

@end

@implementation LYRTgetAccountsWithApps_args

- (id) init
{
  self = [super init];
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getAccountsWithApps_args"];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getAccountsWithApps_args("];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTGetAccountsWithApps_result : NSObject <TBase, NSCoding> {
  LYRTAccountsWithApps __success;
  LYRTNotFoundException * __nfException;
  LYRTInternalException * __intException;

  BOOL __success_isset;
  BOOL __nfException_isset;
  BOOL __intException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) LYRTAccountsWithApps success;
@property (nonatomic, retain, getter=nfException, setter=setNfException:) LYRTNotFoundException * nfException;
@property (nonatomic, retain, getter=intException, setter=setIntException:) LYRTInternalException * intException;
#endif

- (id) init;
- (id) initWithSuccess: (LYRTAccountsWithApps) success nfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTAccountsWithApps) success;
- (void) setSuccess: (LYRTAccountsWithApps) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (LYRTNotFoundException *) nfException;
- (void) setNfException: (LYRTNotFoundException *) nfException;
#endif
- (BOOL) nfExceptionIsSet;

#if !__has_feature(objc_arc)
- (LYRTInternalException *) intException;
- (void) setIntException: (LYRTInternalException *) intException;
#endif
- (BOOL) intExceptionIsSet;

@end

@implementation LYRTGetAccountsWithApps_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (LYRTAccountsWithApps) success nfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __nfException = [nfException retain_stub];
  __nfException_isset = YES;
  __intException = [intException retain_stub];
  __intException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"nfException"])
  {
    __nfException = [[decoder decodeObjectForKey: @"nfException"] retain_stub];
    __nfException_isset = YES;
  }
  if ([decoder containsValueForKey: @"intException"])
  {
    __intException = [[decoder decodeObjectForKey: @"intException"] retain_stub];
    __intException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__nfException_isset)
  {
    [encoder encodeObject: __nfException forKey: @"nfException"];
  }
  if (__intException_isset)
  {
    [encoder encodeObject: __intException forKey: @"intException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__nfException release_stub];
  [__intException release_stub];
  [super dealloc_stub];
}

- (NSMutableArray *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (NSMutableArray *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (LYRTNotFoundException *) nfException {
  return [[__nfException retain_stub] autorelease_stub];
}

- (void) setNfException: (LYRTNotFoundException *) nfException {
  [nfException retain_stub];
  [__nfException release_stub];
  __nfException = nfException;
  __nfException_isset = YES;
}

- (BOOL) nfExceptionIsSet {
  return __nfException_isset;
}

- (void) unsetNfException {
  [__nfException release_stub];
  __nfException = nil;
  __nfException_isset = NO;
}

- (LYRTInternalException *) intException {
  return [[__intException retain_stub] autorelease_stub];
}

- (void) setIntException: (LYRTInternalException *) intException {
  [intException retain_stub];
  [__intException release_stub];
  __intException = intException;
  __intException_isset = YES;
}

- (BOOL) intExceptionIsSet {
  return __intException_isset;
}

- (void) unsetIntException {
  [__intException release_stub];
  __intException = nil;
  __intException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size10;
          [inProtocol readListBeginReturningElementType: NULL size: &_size10];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size10];
          int _i11;
          for (_i11 = 0; _i11 < _size10; ++_i11)
          {
            LYRTAccountApps *_elem12 = [[LYRTAccountApps alloc] init];
            [_elem12 read: inProtocol];
            [fieldValue addObject: _elem12];
            [_elem12 release_stub];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTNotFoundException *fieldValue = [[LYRTNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNfException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          LYRTInternalException *fieldValue = [[LYRTInternalException alloc] init];
          [fieldValue read: inProtocol];
          [self setIntException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetAccountsWithApps_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        int i14;
        for (i14 = 0; i14 < [__success count]; i14++)
        {
          [[__success objectAtIndex: i14] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__nfException_isset) {
    if (__nfException != nil) {
      [outProtocol writeFieldBeginWithName: @"nfException" type: TType_STRUCT fieldID: 1];
      [__nfException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__intException_isset) {
    if (__intException != nil) {
      [outProtocol writeFieldBeginWithName: @"intException" type: TType_STRUCT fieldID: 2];
      [__intException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetAccountsWithApps_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",nfException:"];
  [ms appendFormat: @"%@", __nfException];
  [ms appendString: @",intException:"];
  [ms appendFormat: @"%@", __intException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTsetApnsCertificate_args : NSObject <TBase, NSCoding> {
  LYRTUUID __app_id;
  NSData * __p12_archive;
  NSString * __password;
  BOOL __is_sandbox;

  BOOL __app_id_isset;
  BOOL __p12_archive_isset;
  BOOL __password_isset;
  BOOL __is_sandbox_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=app_id, setter=setApp_id:) LYRTUUID app_id;
@property (nonatomic, retain, getter=p12_archive, setter=setP12_archive:) NSData * p12_archive;
@property (nonatomic, retain, getter=password, setter=setPassword:) NSString * password;
@property (nonatomic, getter=is_sandbox, setter=setIs_sandbox:) BOOL is_sandbox;
#endif

- (id) init;
- (id) initWithApp_id: (LYRTUUID) app_id p12_archive: (NSData *) p12_archive password: (NSString *) password is_sandbox: (BOOL) is_sandbox;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTUUID) app_id;
- (void) setApp_id: (LYRTUUID) app_id;
#endif
- (BOOL) app_idIsSet;

#if !__has_feature(objc_arc)
- (NSData *) p12_archive;
- (void) setP12_archive: (NSData *) p12_archive;
#endif
- (BOOL) p12_archiveIsSet;

#if !__has_feature(objc_arc)
- (NSString *) password;
- (void) setPassword: (NSString *) password;
#endif
- (BOOL) passwordIsSet;

#if !__has_feature(objc_arc)
- (BOOL) is_sandbox;
- (void) setIs_sandbox: (BOOL) is_sandbox;
#endif
- (BOOL) is_sandboxIsSet;

@end

@implementation LYRTsetApnsCertificate_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithApp_id: (LYRTUUID) app_id p12_archive: (NSData *) p12_archive password: (NSString *) password is_sandbox: (BOOL) is_sandbox
{
  self = [super init];
  __app_id = [app_id retain_stub];
  __app_id_isset = YES;
  __p12_archive = [p12_archive retain_stub];
  __p12_archive_isset = YES;
  __password = [password retain_stub];
  __password_isset = YES;
  __is_sandbox = is_sandbox;
  __is_sandbox_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"app_id"])
  {
    __app_id = [[decoder decodeObjectForKey: @"app_id"] retain_stub];
    __app_id_isset = YES;
  }
  if ([decoder containsValueForKey: @"p12_archive"])
  {
    __p12_archive = [[decoder decodeObjectForKey: @"p12_archive"] retain_stub];
    __p12_archive_isset = YES;
  }
  if ([decoder containsValueForKey: @"password"])
  {
    __password = [[decoder decodeObjectForKey: @"password"] retain_stub];
    __password_isset = YES;
  }
  if ([decoder containsValueForKey: @"is_sandbox"])
  {
    __is_sandbox = [decoder decodeBoolForKey: @"is_sandbox"];
    __is_sandbox_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__app_id_isset)
  {
    [encoder encodeObject: __app_id forKey: @"app_id"];
  }
  if (__p12_archive_isset)
  {
    [encoder encodeObject: __p12_archive forKey: @"p12_archive"];
  }
  if (__password_isset)
  {
    [encoder encodeObject: __password forKey: @"password"];
  }
  if (__is_sandbox_isset)
  {
    [encoder encodeBool: __is_sandbox forKey: @"is_sandbox"];
  }
}

- (void) dealloc
{
  [__app_id release_stub];
  [__p12_archive release_stub];
  [__password release_stub];
  [super dealloc_stub];
}

- (NSData *) app_id {
  return [[__app_id retain_stub] autorelease_stub];
}

- (void) setApp_id: (NSData *) app_id {
  [app_id retain_stub];
  [__app_id release_stub];
  __app_id = app_id;
  __app_id_isset = YES;
}

- (BOOL) app_idIsSet {
  return __app_id_isset;
}

- (void) unsetApp_id {
  [__app_id release_stub];
  __app_id = nil;
  __app_id_isset = NO;
}

- (NSData *) p12_archive {
  return [[__p12_archive retain_stub] autorelease_stub];
}

- (void) setP12_archive: (NSData *) p12_archive {
  [p12_archive retain_stub];
  [__p12_archive release_stub];
  __p12_archive = p12_archive;
  __p12_archive_isset = YES;
}

- (BOOL) p12_archiveIsSet {
  return __p12_archive_isset;
}

- (void) unsetP12_archive {
  [__p12_archive release_stub];
  __p12_archive = nil;
  __p12_archive_isset = NO;
}

- (NSString *) password {
  return [[__password retain_stub] autorelease_stub];
}

- (void) setPassword: (NSString *) password {
  [password retain_stub];
  [__password release_stub];
  __password = password;
  __password_isset = YES;
}

- (BOOL) passwordIsSet {
  return __password_isset;
}

- (void) unsetPassword {
  [__password release_stub];
  __password = nil;
  __password_isset = NO;
}

- (BOOL) is_sandbox {
  return __is_sandbox;
}

- (void) setIs_sandbox: (BOOL) is_sandbox {
  __is_sandbox = is_sandbox;
  __is_sandbox_isset = YES;
}

- (BOOL) is_sandboxIsSet {
  return __is_sandbox_isset;
}

- (void) unsetIs_sandbox {
  __is_sandbox_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setApp_id: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setP12_archive: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setPassword: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIs_sandbox: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"setApnsCertificate_args"];
  if (__app_id_isset) {
    if (__app_id != nil) {
      [outProtocol writeFieldBeginWithName: @"app_id" type: TType_STRING fieldID: 1];
      [outProtocol writeBinary: __app_id];
      [outProtocol writeFieldEnd];
    }
  }
  if (__p12_archive_isset) {
    if (__p12_archive != nil) {
      [outProtocol writeFieldBeginWithName: @"p12_archive" type: TType_STRING fieldID: 2];
      [outProtocol writeBinary: __p12_archive];
      [outProtocol writeFieldEnd];
    }
  }
  if (__password_isset) {
    if (__password != nil) {
      [outProtocol writeFieldBeginWithName: @"password" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __password];
      [outProtocol writeFieldEnd];
    }
  }
  if (__is_sandbox_isset) {
    [outProtocol writeFieldBeginWithName: @"is_sandbox" type: TType_BOOL fieldID: 4];
    [outProtocol writeBool: __is_sandbox];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"setApnsCertificate_args("];
  [ms appendString: @"app_id:"];
  [ms appendFormat: @"\"%@\"", __app_id];
  [ms appendString: @",p12_archive:"];
  [ms appendFormat: @"\"%@\"", __p12_archive];
  [ms appendString: @",password:"];
  [ms appendFormat: @"\"%@\"", __password];
  [ms appendString: @",is_sandbox:"];
  [ms appendFormat: @"%i", __is_sandbox];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTSetApnsCertificate_result : NSObject <TBase, NSCoding> {
  LYRTNotFoundException * __nfException;
  LYRTInternalException * __intException;
  LYRTBadRequestException * __brException;

  BOOL __nfException_isset;
  BOOL __intException_isset;
  BOOL __brException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=nfException, setter=setNfException:) LYRTNotFoundException * nfException;
@property (nonatomic, retain, getter=intException, setter=setIntException:) LYRTInternalException * intException;
@property (nonatomic, retain, getter=brException, setter=setBrException:) LYRTBadRequestException * brException;
#endif

- (id) init;
- (id) initWithNfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException brException: (LYRTBadRequestException *) brException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTNotFoundException *) nfException;
- (void) setNfException: (LYRTNotFoundException *) nfException;
#endif
- (BOOL) nfExceptionIsSet;

#if !__has_feature(objc_arc)
- (LYRTInternalException *) intException;
- (void) setIntException: (LYRTInternalException *) intException;
#endif
- (BOOL) intExceptionIsSet;

#if !__has_feature(objc_arc)
- (LYRTBadRequestException *) brException;
- (void) setBrException: (LYRTBadRequestException *) brException;
#endif
- (BOOL) brExceptionIsSet;

@end

@implementation LYRTSetApnsCertificate_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithNfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException brException: (LYRTBadRequestException *) brException
{
  self = [super init];
  __nfException = [nfException retain_stub];
  __nfException_isset = YES;
  __intException = [intException retain_stub];
  __intException_isset = YES;
  __brException = [brException retain_stub];
  __brException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"nfException"])
  {
    __nfException = [[decoder decodeObjectForKey: @"nfException"] retain_stub];
    __nfException_isset = YES;
  }
  if ([decoder containsValueForKey: @"intException"])
  {
    __intException = [[decoder decodeObjectForKey: @"intException"] retain_stub];
    __intException_isset = YES;
  }
  if ([decoder containsValueForKey: @"brException"])
  {
    __brException = [[decoder decodeObjectForKey: @"brException"] retain_stub];
    __brException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__nfException_isset)
  {
    [encoder encodeObject: __nfException forKey: @"nfException"];
  }
  if (__intException_isset)
  {
    [encoder encodeObject: __intException forKey: @"intException"];
  }
  if (__brException_isset)
  {
    [encoder encodeObject: __brException forKey: @"brException"];
  }
}

- (void) dealloc
{
  [__nfException release_stub];
  [__intException release_stub];
  [__brException release_stub];
  [super dealloc_stub];
}

- (LYRTNotFoundException *) nfException {
  return [[__nfException retain_stub] autorelease_stub];
}

- (void) setNfException: (LYRTNotFoundException *) nfException {
  [nfException retain_stub];
  [__nfException release_stub];
  __nfException = nfException;
  __nfException_isset = YES;
}

- (BOOL) nfExceptionIsSet {
  return __nfException_isset;
}

- (void) unsetNfException {
  [__nfException release_stub];
  __nfException = nil;
  __nfException_isset = NO;
}

- (LYRTInternalException *) intException {
  return [[__intException retain_stub] autorelease_stub];
}

- (void) setIntException: (LYRTInternalException *) intException {
  [intException retain_stub];
  [__intException release_stub];
  __intException = intException;
  __intException_isset = YES;
}

- (BOOL) intExceptionIsSet {
  return __intException_isset;
}

- (void) unsetIntException {
  [__intException release_stub];
  __intException = nil;
  __intException_isset = NO;
}

- (LYRTBadRequestException *) brException {
  return [[__brException retain_stub] autorelease_stub];
}

- (void) setBrException: (LYRTBadRequestException *) brException {
  [brException retain_stub];
  [__brException release_stub];
  __brException = brException;
  __brException_isset = YES;
}

- (BOOL) brExceptionIsSet {
  return __brException_isset;
}

- (void) unsetBrException {
  [__brException release_stub];
  __brException = nil;
  __brException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTNotFoundException *fieldValue = [[LYRTNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNfException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          LYRTInternalException *fieldValue = [[LYRTInternalException alloc] init];
          [fieldValue read: inProtocol];
          [self setIntException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          LYRTBadRequestException *fieldValue = [[LYRTBadRequestException alloc] init];
          [fieldValue read: inProtocol];
          [self setBrException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"SetApnsCertificate_result"];

  if (__nfException_isset) {
    if (__nfException != nil) {
      [outProtocol writeFieldBeginWithName: @"nfException" type: TType_STRUCT fieldID: 1];
      [__nfException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__intException_isset) {
    if (__intException != nil) {
      [outProtocol writeFieldBeginWithName: @"intException" type: TType_STRUCT fieldID: 2];
      [__intException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__brException_isset) {
    if (__brException != nil) {
      [outProtocol writeFieldBeginWithName: @"brException" type: TType_STRUCT fieldID: 3];
      [__brException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"SetApnsCertificate_result("];
  [ms appendString: @"nfException:"];
  [ms appendFormat: @"%@", __nfException];
  [ms appendString: @",intException:"];
  [ms appendFormat: @"%@", __intException];
  [ms appendString: @",brException:"];
  [ms appendFormat: @"%@", __brException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTgetApp_args : NSObject <TBase, NSCoding> {
  LYRTUUID __app_id;

  BOOL __app_id_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=app_id, setter=setApp_id:) LYRTUUID app_id;
#endif

- (id) init;
- (id) initWithApp_id: (LYRTUUID) app_id;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTUUID) app_id;
- (void) setApp_id: (LYRTUUID) app_id;
#endif
- (BOOL) app_idIsSet;

@end

@implementation LYRTgetApp_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithApp_id: (LYRTUUID) app_id
{
  self = [super init];
  __app_id = [app_id retain_stub];
  __app_id_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"app_id"])
  {
    __app_id = [[decoder decodeObjectForKey: @"app_id"] retain_stub];
    __app_id_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__app_id_isset)
  {
    [encoder encodeObject: __app_id forKey: @"app_id"];
  }
}

- (void) dealloc
{
  [__app_id release_stub];
  [super dealloc_stub];
}

- (NSData *) app_id {
  return [[__app_id retain_stub] autorelease_stub];
}

- (void) setApp_id: (NSData *) app_id {
  [app_id retain_stub];
  [__app_id release_stub];
  __app_id = app_id;
  __app_id_isset = YES;
}

- (BOOL) app_idIsSet {
  return __app_id_isset;
}

- (void) unsetApp_id {
  [__app_id release_stub];
  __app_id = nil;
  __app_id_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setApp_id: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getApp_args"];
  if (__app_id_isset) {
    if (__app_id != nil) {
      [outProtocol writeFieldBeginWithName: @"app_id" type: TType_STRING fieldID: 1];
      [outProtocol writeBinary: __app_id];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getApp_args("];
  [ms appendString: @"app_id:"];
  [ms appendFormat: @"\"%@\"", __app_id];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTGetApp_result : NSObject <TBase, NSCoding> {
  LYRTApp * __success;
  LYRTNotFoundException * __nfException;
  LYRTInternalException * __intException;

  BOOL __success_isset;
  BOOL __nfException_isset;
  BOOL __intException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) LYRTApp * success;
@property (nonatomic, retain, getter=nfException, setter=setNfException:) LYRTNotFoundException * nfException;
@property (nonatomic, retain, getter=intException, setter=setIntException:) LYRTInternalException * intException;
#endif

- (id) init;
- (id) initWithSuccess: (LYRTApp *) success nfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTApp *) success;
- (void) setSuccess: (LYRTApp *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (LYRTNotFoundException *) nfException;
- (void) setNfException: (LYRTNotFoundException *) nfException;
#endif
- (BOOL) nfExceptionIsSet;

#if !__has_feature(objc_arc)
- (LYRTInternalException *) intException;
- (void) setIntException: (LYRTInternalException *) intException;
#endif
- (BOOL) intExceptionIsSet;

@end

@implementation LYRTGetApp_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (LYRTApp *) success nfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __nfException = [nfException retain_stub];
  __nfException_isset = YES;
  __intException = [intException retain_stub];
  __intException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"nfException"])
  {
    __nfException = [[decoder decodeObjectForKey: @"nfException"] retain_stub];
    __nfException_isset = YES;
  }
  if ([decoder containsValueForKey: @"intException"])
  {
    __intException = [[decoder decodeObjectForKey: @"intException"] retain_stub];
    __intException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__nfException_isset)
  {
    [encoder encodeObject: __nfException forKey: @"nfException"];
  }
  if (__intException_isset)
  {
    [encoder encodeObject: __intException forKey: @"intException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__nfException release_stub];
  [__intException release_stub];
  [super dealloc_stub];
}

- (LYRTApp *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (LYRTApp *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (LYRTNotFoundException *) nfException {
  return [[__nfException retain_stub] autorelease_stub];
}

- (void) setNfException: (LYRTNotFoundException *) nfException {
  [nfException retain_stub];
  [__nfException release_stub];
  __nfException = nfException;
  __nfException_isset = YES;
}

- (BOOL) nfExceptionIsSet {
  return __nfException_isset;
}

- (void) unsetNfException {
  [__nfException release_stub];
  __nfException = nil;
  __nfException_isset = NO;
}

- (LYRTInternalException *) intException {
  return [[__intException retain_stub] autorelease_stub];
}

- (void) setIntException: (LYRTInternalException *) intException {
  [intException retain_stub];
  [__intException release_stub];
  __intException = intException;
  __intException_isset = YES;
}

- (BOOL) intExceptionIsSet {
  return __intException_isset;
}

- (void) unsetIntException {
  [__intException release_stub];
  __intException = nil;
  __intException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          LYRTApp *fieldValue = [[LYRTApp alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTNotFoundException *fieldValue = [[LYRTNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNfException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          LYRTInternalException *fieldValue = [[LYRTInternalException alloc] init];
          [fieldValue read: inProtocol];
          [self setIntException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetApp_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__nfException_isset) {
    if (__nfException != nil) {
      [outProtocol writeFieldBeginWithName: @"nfException" type: TType_STRUCT fieldID: 1];
      [__nfException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__intException_isset) {
    if (__intException != nil) {
      [outProtocol writeFieldBeginWithName: @"intException" type: TType_STRUCT fieldID: 2];
      [__intException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetApp_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",nfException:"];
  [ms appendFormat: @"%@", __nfException];
  [ms appendString: @",intException:"];
  [ms appendFormat: @"%@", __intException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTupdateApp_args : NSObject <TBase, NSCoding> {
  LYRTApp * __app;

  BOOL __app_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=app, setter=setApp:) LYRTApp * app;
#endif

- (id) init;
- (id) initWithApp: (LYRTApp *) app;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTApp *) app;
- (void) setApp: (LYRTApp *) app;
#endif
- (BOOL) appIsSet;

@end

@implementation LYRTupdateApp_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithApp: (LYRTApp *) app
{
  self = [super init];
  __app = [app retain_stub];
  __app_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"app"])
  {
    __app = [[decoder decodeObjectForKey: @"app"] retain_stub];
    __app_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__app_isset)
  {
    [encoder encodeObject: __app forKey: @"app"];
  }
}

- (void) dealloc
{
  [__app release_stub];
  [super dealloc_stub];
}

- (LYRTApp *) app {
  return [[__app retain_stub] autorelease_stub];
}

- (void) setApp: (LYRTApp *) app {
  [app retain_stub];
  [__app release_stub];
  __app = app;
  __app_isset = YES;
}

- (BOOL) appIsSet {
  return __app_isset;
}

- (void) unsetApp {
  [__app release_stub];
  __app = nil;
  __app_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTApp *fieldValue = [[LYRTApp alloc] init];
          [fieldValue read: inProtocol];
          [self setApp: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"updateApp_args"];
  if (__app_isset) {
    if (__app != nil) {
      [outProtocol writeFieldBeginWithName: @"app" type: TType_STRUCT fieldID: 1];
      [__app write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"updateApp_args("];
  [ms appendString: @"app:"];
  [ms appendFormat: @"%@", __app];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTUpdateApp_result : NSObject <TBase, NSCoding> {
  LYRTNotFoundException * __nfException;
  LYRTInternalException * __intException;

  BOOL __nfException_isset;
  BOOL __intException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=nfException, setter=setNfException:) LYRTNotFoundException * nfException;
@property (nonatomic, retain, getter=intException, setter=setIntException:) LYRTInternalException * intException;
#endif

- (id) init;
- (id) initWithNfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTNotFoundException *) nfException;
- (void) setNfException: (LYRTNotFoundException *) nfException;
#endif
- (BOOL) nfExceptionIsSet;

#if !__has_feature(objc_arc)
- (LYRTInternalException *) intException;
- (void) setIntException: (LYRTInternalException *) intException;
#endif
- (BOOL) intExceptionIsSet;

@end

@implementation LYRTUpdateApp_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithNfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException
{
  self = [super init];
  __nfException = [nfException retain_stub];
  __nfException_isset = YES;
  __intException = [intException retain_stub];
  __intException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"nfException"])
  {
    __nfException = [[decoder decodeObjectForKey: @"nfException"] retain_stub];
    __nfException_isset = YES;
  }
  if ([decoder containsValueForKey: @"intException"])
  {
    __intException = [[decoder decodeObjectForKey: @"intException"] retain_stub];
    __intException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__nfException_isset)
  {
    [encoder encodeObject: __nfException forKey: @"nfException"];
  }
  if (__intException_isset)
  {
    [encoder encodeObject: __intException forKey: @"intException"];
  }
}

- (void) dealloc
{
  [__nfException release_stub];
  [__intException release_stub];
  [super dealloc_stub];
}

- (LYRTNotFoundException *) nfException {
  return [[__nfException retain_stub] autorelease_stub];
}

- (void) setNfException: (LYRTNotFoundException *) nfException {
  [nfException retain_stub];
  [__nfException release_stub];
  __nfException = nfException;
  __nfException_isset = YES;
}

- (BOOL) nfExceptionIsSet {
  return __nfException_isset;
}

- (void) unsetNfException {
  [__nfException release_stub];
  __nfException = nil;
  __nfException_isset = NO;
}

- (LYRTInternalException *) intException {
  return [[__intException retain_stub] autorelease_stub];
}

- (void) setIntException: (LYRTInternalException *) intException {
  [intException retain_stub];
  [__intException release_stub];
  __intException = intException;
  __intException_isset = YES;
}

- (BOOL) intExceptionIsSet {
  return __intException_isset;
}

- (void) unsetIntException {
  [__intException release_stub];
  __intException = nil;
  __intException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTNotFoundException *fieldValue = [[LYRTNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNfException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          LYRTInternalException *fieldValue = [[LYRTInternalException alloc] init];
          [fieldValue read: inProtocol];
          [self setIntException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UpdateApp_result"];

  if (__nfException_isset) {
    if (__nfException != nil) {
      [outProtocol writeFieldBeginWithName: @"nfException" type: TType_STRUCT fieldID: 1];
      [__nfException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__intException_isset) {
    if (__intException != nil) {
      [outProtocol writeFieldBeginWithName: @"intException" type: TType_STRUCT fieldID: 2];
      [__intException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UpdateApp_result("];
  [ms appendString: @"nfException:"];
  [ms appendFormat: @"%@", __nfException];
  [ms appendString: @",intException:"];
  [ms appendFormat: @"%@", __intException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTcreateApp_args : NSObject <TBase, NSCoding> {
  LYRTUUID __account_id;
  LYRTApp * __app;

  BOOL __account_id_isset;
  BOOL __app_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=account_id, setter=setAccount_id:) LYRTUUID account_id;
@property (nonatomic, retain, getter=app, setter=setApp:) LYRTApp * app;
#endif

- (id) init;
- (id) initWithAccount_id: (LYRTUUID) account_id app: (LYRTApp *) app;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTUUID) account_id;
- (void) setAccount_id: (LYRTUUID) account_id;
#endif
- (BOOL) account_idIsSet;

#if !__has_feature(objc_arc)
- (LYRTApp *) app;
- (void) setApp: (LYRTApp *) app;
#endif
- (BOOL) appIsSet;

@end

@implementation LYRTcreateApp_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAccount_id: (LYRTUUID) account_id app: (LYRTApp *) app
{
  self = [super init];
  __account_id = [account_id retain_stub];
  __account_id_isset = YES;
  __app = [app retain_stub];
  __app_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"account_id"])
  {
    __account_id = [[decoder decodeObjectForKey: @"account_id"] retain_stub];
    __account_id_isset = YES;
  }
  if ([decoder containsValueForKey: @"app"])
  {
    __app = [[decoder decodeObjectForKey: @"app"] retain_stub];
    __app_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__account_id_isset)
  {
    [encoder encodeObject: __account_id forKey: @"account_id"];
  }
  if (__app_isset)
  {
    [encoder encodeObject: __app forKey: @"app"];
  }
}

- (void) dealloc
{
  [__account_id release_stub];
  [__app release_stub];
  [super dealloc_stub];
}

- (NSData *) account_id {
  return [[__account_id retain_stub] autorelease_stub];
}

- (void) setAccount_id: (NSData *) account_id {
  [account_id retain_stub];
  [__account_id release_stub];
  __account_id = account_id;
  __account_id_isset = YES;
}

- (BOOL) account_idIsSet {
  return __account_id_isset;
}

- (void) unsetAccount_id {
  [__account_id release_stub];
  __account_id = nil;
  __account_id_isset = NO;
}

- (LYRTApp *) app {
  return [[__app retain_stub] autorelease_stub];
}

- (void) setApp: (LYRTApp *) app {
  [app retain_stub];
  [__app release_stub];
  __app = app;
  __app_isset = YES;
}

- (BOOL) appIsSet {
  return __app_isset;
}

- (void) unsetApp {
  [__app release_stub];
  __app = nil;
  __app_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setAccount_id: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          LYRTApp *fieldValue = [[LYRTApp alloc] init];
          [fieldValue read: inProtocol];
          [self setApp: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"createApp_args"];
  if (__account_id_isset) {
    if (__account_id != nil) {
      [outProtocol writeFieldBeginWithName: @"account_id" type: TType_STRING fieldID: 1];
      [outProtocol writeBinary: __account_id];
      [outProtocol writeFieldEnd];
    }
  }
  if (__app_isset) {
    if (__app != nil) {
      [outProtocol writeFieldBeginWithName: @"app" type: TType_STRUCT fieldID: 2];
      [__app write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"createApp_args("];
  [ms appendString: @"account_id:"];
  [ms appendFormat: @"\"%@\"", __account_id];
  [ms appendString: @",app:"];
  [ms appendFormat: @"%@", __app];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTCreateApp_result : NSObject <TBase, NSCoding> {
  LYRTApp * __success;
  LYRTInternalException * __intException;

  BOOL __success_isset;
  BOOL __intException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) LYRTApp * success;
@property (nonatomic, retain, getter=intException, setter=setIntException:) LYRTInternalException * intException;
#endif

- (id) init;
- (id) initWithSuccess: (LYRTApp *) success intException: (LYRTInternalException *) intException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTApp *) success;
- (void) setSuccess: (LYRTApp *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (LYRTInternalException *) intException;
- (void) setIntException: (LYRTInternalException *) intException;
#endif
- (BOOL) intExceptionIsSet;

@end

@implementation LYRTCreateApp_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (LYRTApp *) success intException: (LYRTInternalException *) intException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __intException = [intException retain_stub];
  __intException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"intException"])
  {
    __intException = [[decoder decodeObjectForKey: @"intException"] retain_stub];
    __intException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__intException_isset)
  {
    [encoder encodeObject: __intException forKey: @"intException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__intException release_stub];
  [super dealloc_stub];
}

- (LYRTApp *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (LYRTApp *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (LYRTInternalException *) intException {
  return [[__intException retain_stub] autorelease_stub];
}

- (void) setIntException: (LYRTInternalException *) intException {
  [intException retain_stub];
  [__intException release_stub];
  __intException = intException;
  __intException_isset = YES;
}

- (BOOL) intExceptionIsSet {
  return __intException_isset;
}

- (void) unsetIntException {
  [__intException release_stub];
  __intException = nil;
  __intException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          LYRTApp *fieldValue = [[LYRTApp alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTInternalException *fieldValue = [[LYRTInternalException alloc] init];
          [fieldValue read: inProtocol];
          [self setIntException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CreateApp_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__intException_isset) {
    if (__intException != nil) {
      [outProtocol writeFieldBeginWithName: @"intException" type: TType_STRUCT fieldID: 1];
      [__intException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CreateApp_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",intException:"];
  [ms appendFormat: @"%@", __intException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTgetAppsFromAccount_args : NSObject <TBase, NSCoding> {
  LYRTUUID __account_id;

  BOOL __account_id_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=account_id, setter=setAccount_id:) LYRTUUID account_id;
#endif

- (id) init;
- (id) initWithAccount_id: (LYRTUUID) account_id;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTUUID) account_id;
- (void) setAccount_id: (LYRTUUID) account_id;
#endif
- (BOOL) account_idIsSet;

@end

@implementation LYRTgetAppsFromAccount_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAccount_id: (LYRTUUID) account_id
{
  self = [super init];
  __account_id = [account_id retain_stub];
  __account_id_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"account_id"])
  {
    __account_id = [[decoder decodeObjectForKey: @"account_id"] retain_stub];
    __account_id_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__account_id_isset)
  {
    [encoder encodeObject: __account_id forKey: @"account_id"];
  }
}

- (void) dealloc
{
  [__account_id release_stub];
  [super dealloc_stub];
}

- (NSData *) account_id {
  return [[__account_id retain_stub] autorelease_stub];
}

- (void) setAccount_id: (NSData *) account_id {
  [account_id retain_stub];
  [__account_id release_stub];
  __account_id = account_id;
  __account_id_isset = YES;
}

- (BOOL) account_idIsSet {
  return __account_id_isset;
}

- (void) unsetAccount_id {
  [__account_id release_stub];
  __account_id = nil;
  __account_id_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setAccount_id: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getAppsFromAccount_args"];
  if (__account_id_isset) {
    if (__account_id != nil) {
      [outProtocol writeFieldBeginWithName: @"account_id" type: TType_STRING fieldID: 1];
      [outProtocol writeBinary: __account_id];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getAppsFromAccount_args("];
  [ms appendString: @"account_id:"];
  [ms appendFormat: @"\"%@\"", __account_id];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTGetAppsFromAccount_result : NSObject <TBase, NSCoding> {
  LYRTApps __success;
  LYRTNotFoundException * __nfException;
  LYRTInternalException * __intException;

  BOOL __success_isset;
  BOOL __nfException_isset;
  BOOL __intException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) LYRTApps success;
@property (nonatomic, retain, getter=nfException, setter=setNfException:) LYRTNotFoundException * nfException;
@property (nonatomic, retain, getter=intException, setter=setIntException:) LYRTInternalException * intException;
#endif

- (id) init;
- (id) initWithSuccess: (LYRTApps) success nfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTApps) success;
- (void) setSuccess: (LYRTApps) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (LYRTNotFoundException *) nfException;
- (void) setNfException: (LYRTNotFoundException *) nfException;
#endif
- (BOOL) nfExceptionIsSet;

#if !__has_feature(objc_arc)
- (LYRTInternalException *) intException;
- (void) setIntException: (LYRTInternalException *) intException;
#endif
- (BOOL) intExceptionIsSet;

@end

@implementation LYRTGetAppsFromAccount_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (LYRTApps) success nfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __nfException = [nfException retain_stub];
  __nfException_isset = YES;
  __intException = [intException retain_stub];
  __intException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"nfException"])
  {
    __nfException = [[decoder decodeObjectForKey: @"nfException"] retain_stub];
    __nfException_isset = YES;
  }
  if ([decoder containsValueForKey: @"intException"])
  {
    __intException = [[decoder decodeObjectForKey: @"intException"] retain_stub];
    __intException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__nfException_isset)
  {
    [encoder encodeObject: __nfException forKey: @"nfException"];
  }
  if (__intException_isset)
  {
    [encoder encodeObject: __intException forKey: @"intException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__nfException release_stub];
  [__intException release_stub];
  [super dealloc_stub];
}

- (NSMutableArray *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (NSMutableArray *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (LYRTNotFoundException *) nfException {
  return [[__nfException retain_stub] autorelease_stub];
}

- (void) setNfException: (LYRTNotFoundException *) nfException {
  [nfException retain_stub];
  [__nfException release_stub];
  __nfException = nfException;
  __nfException_isset = YES;
}

- (BOOL) nfExceptionIsSet {
  return __nfException_isset;
}

- (void) unsetNfException {
  [__nfException release_stub];
  __nfException = nil;
  __nfException_isset = NO;
}

- (LYRTInternalException *) intException {
  return [[__intException retain_stub] autorelease_stub];
}

- (void) setIntException: (LYRTInternalException *) intException {
  [intException retain_stub];
  [__intException release_stub];
  __intException = intException;
  __intException_isset = YES;
}

- (BOOL) intExceptionIsSet {
  return __intException_isset;
}

- (void) unsetIntException {
  [__intException release_stub];
  __intException = nil;
  __intException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size15;
          [inProtocol readListBeginReturningElementType: NULL size: &_size15];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size15];
          int _i16;
          for (_i16 = 0; _i16 < _size15; ++_i16)
          {
            LYRTApp *_elem17 = [[LYRTApp alloc] init];
            [_elem17 read: inProtocol];
            [fieldValue addObject: _elem17];
            [_elem17 release_stub];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTNotFoundException *fieldValue = [[LYRTNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNfException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          LYRTInternalException *fieldValue = [[LYRTInternalException alloc] init];
          [fieldValue read: inProtocol];
          [self setIntException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetAppsFromAccount_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        int i19;
        for (i19 = 0; i19 < [__success count]; i19++)
        {
          [[__success objectAtIndex: i19] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__nfException_isset) {
    if (__nfException != nil) {
      [outProtocol writeFieldBeginWithName: @"nfException" type: TType_STRUCT fieldID: 1];
      [__nfException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__intException_isset) {
    if (__intException != nil) {
      [outProtocol writeFieldBeginWithName: @"intException" type: TType_STRUCT fieldID: 2];
      [__intException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetAppsFromAccount_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",nfException:"];
  [ms appendFormat: @"%@", __nfException];
  [ms appendString: @",intException:"];
  [ms appendFormat: @"%@", __intException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTaddPublicKey_args : NSObject <TBase, NSCoding> {
  LYRTPublicKey * __public_key;

  BOOL __public_key_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=public_key, setter=setPublic_key:) LYRTPublicKey * public_key;
#endif

- (id) init;
- (id) initWithPublic_key: (LYRTPublicKey *) public_key;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTPublicKey *) public_key;
- (void) setPublic_key: (LYRTPublicKey *) public_key;
#endif
- (BOOL) public_keyIsSet;

@end

@implementation LYRTaddPublicKey_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithPublic_key: (LYRTPublicKey *) public_key
{
  self = [super init];
  __public_key = [public_key retain_stub];
  __public_key_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"public_key"])
  {
    __public_key = [[decoder decodeObjectForKey: @"public_key"] retain_stub];
    __public_key_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__public_key_isset)
  {
    [encoder encodeObject: __public_key forKey: @"public_key"];
  }
}

- (void) dealloc
{
  [__public_key release_stub];
  [super dealloc_stub];
}

- (LYRTPublicKey *) public_key {
  return [[__public_key retain_stub] autorelease_stub];
}

- (void) setPublic_key: (LYRTPublicKey *) public_key {
  [public_key retain_stub];
  [__public_key release_stub];
  __public_key = public_key;
  __public_key_isset = YES;
}

- (BOOL) public_keyIsSet {
  return __public_key_isset;
}

- (void) unsetPublic_key {
  [__public_key release_stub];
  __public_key = nil;
  __public_key_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTPublicKey *fieldValue = [[LYRTPublicKey alloc] init];
          [fieldValue read: inProtocol];
          [self setPublic_key: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"addPublicKey_args"];
  if (__public_key_isset) {
    if (__public_key != nil) {
      [outProtocol writeFieldBeginWithName: @"public_key" type: TType_STRUCT fieldID: 1];
      [__public_key write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"addPublicKey_args("];
  [ms appendString: @"public_key:"];
  [ms appendFormat: @"%@", __public_key];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTAddPublicKey_result : NSObject <TBase, NSCoding> {
  LYRTPublicKey * __success;
  LYRTInternalException * __intException;

  BOOL __success_isset;
  BOOL __intException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) LYRTPublicKey * success;
@property (nonatomic, retain, getter=intException, setter=setIntException:) LYRTInternalException * intException;
#endif

- (id) init;
- (id) initWithSuccess: (LYRTPublicKey *) success intException: (LYRTInternalException *) intException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTPublicKey *) success;
- (void) setSuccess: (LYRTPublicKey *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (LYRTInternalException *) intException;
- (void) setIntException: (LYRTInternalException *) intException;
#endif
- (BOOL) intExceptionIsSet;

@end

@implementation LYRTAddPublicKey_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (LYRTPublicKey *) success intException: (LYRTInternalException *) intException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __intException = [intException retain_stub];
  __intException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"intException"])
  {
    __intException = [[decoder decodeObjectForKey: @"intException"] retain_stub];
    __intException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__intException_isset)
  {
    [encoder encodeObject: __intException forKey: @"intException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__intException release_stub];
  [super dealloc_stub];
}

- (LYRTPublicKey *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (LYRTPublicKey *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (LYRTInternalException *) intException {
  return [[__intException retain_stub] autorelease_stub];
}

- (void) setIntException: (LYRTInternalException *) intException {
  [intException retain_stub];
  [__intException release_stub];
  __intException = intException;
  __intException_isset = YES;
}

- (BOOL) intExceptionIsSet {
  return __intException_isset;
}

- (void) unsetIntException {
  [__intException release_stub];
  __intException = nil;
  __intException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          LYRTPublicKey *fieldValue = [[LYRTPublicKey alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTInternalException *fieldValue = [[LYRTInternalException alloc] init];
          [fieldValue read: inProtocol];
          [self setIntException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"AddPublicKey_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__intException_isset) {
    if (__intException != nil) {
      [outProtocol writeFieldBeginWithName: @"intException" type: TType_STRUCT fieldID: 1];
      [__intException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AddPublicKey_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",intException:"];
  [ms appendFormat: @"%@", __intException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTgetPublicKey_args : NSObject <TBase, NSCoding> {
  LYRTUUID __provider_id;
  LYRTUUID __key_id;

  BOOL __provider_id_isset;
  BOOL __key_id_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=provider_id, setter=setProvider_id:) LYRTUUID provider_id;
@property (nonatomic, retain, getter=key_id, setter=setKey_id:) LYRTUUID key_id;
#endif

- (id) init;
- (id) initWithProvider_id: (LYRTUUID) provider_id key_id: (LYRTUUID) key_id;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTUUID) provider_id;
- (void) setProvider_id: (LYRTUUID) provider_id;
#endif
- (BOOL) provider_idIsSet;

#if !__has_feature(objc_arc)
- (LYRTUUID) key_id;
- (void) setKey_id: (LYRTUUID) key_id;
#endif
- (BOOL) key_idIsSet;

@end

@implementation LYRTgetPublicKey_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithProvider_id: (LYRTUUID) provider_id key_id: (LYRTUUID) key_id
{
  self = [super init];
  __provider_id = [provider_id retain_stub];
  __provider_id_isset = YES;
  __key_id = [key_id retain_stub];
  __key_id_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"provider_id"])
  {
    __provider_id = [[decoder decodeObjectForKey: @"provider_id"] retain_stub];
    __provider_id_isset = YES;
  }
  if ([decoder containsValueForKey: @"key_id"])
  {
    __key_id = [[decoder decodeObjectForKey: @"key_id"] retain_stub];
    __key_id_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__provider_id_isset)
  {
    [encoder encodeObject: __provider_id forKey: @"provider_id"];
  }
  if (__key_id_isset)
  {
    [encoder encodeObject: __key_id forKey: @"key_id"];
  }
}

- (void) dealloc
{
  [__provider_id release_stub];
  [__key_id release_stub];
  [super dealloc_stub];
}

- (NSData *) provider_id {
  return [[__provider_id retain_stub] autorelease_stub];
}

- (void) setProvider_id: (NSData *) provider_id {
  [provider_id retain_stub];
  [__provider_id release_stub];
  __provider_id = provider_id;
  __provider_id_isset = YES;
}

- (BOOL) provider_idIsSet {
  return __provider_id_isset;
}

- (void) unsetProvider_id {
  [__provider_id release_stub];
  __provider_id = nil;
  __provider_id_isset = NO;
}

- (NSData *) key_id {
  return [[__key_id retain_stub] autorelease_stub];
}

- (void) setKey_id: (NSData *) key_id {
  [key_id retain_stub];
  [__key_id release_stub];
  __key_id = key_id;
  __key_id_isset = YES;
}

- (BOOL) key_idIsSet {
  return __key_id_isset;
}

- (void) unsetKey_id {
  [__key_id release_stub];
  __key_id = nil;
  __key_id_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setProvider_id: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setKey_id: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getPublicKey_args"];
  if (__provider_id_isset) {
    if (__provider_id != nil) {
      [outProtocol writeFieldBeginWithName: @"provider_id" type: TType_STRING fieldID: 1];
      [outProtocol writeBinary: __provider_id];
      [outProtocol writeFieldEnd];
    }
  }
  if (__key_id_isset) {
    if (__key_id != nil) {
      [outProtocol writeFieldBeginWithName: @"key_id" type: TType_STRING fieldID: 2];
      [outProtocol writeBinary: __key_id];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getPublicKey_args("];
  [ms appendString: @"provider_id:"];
  [ms appendFormat: @"\"%@\"", __provider_id];
  [ms appendString: @",key_id:"];
  [ms appendFormat: @"\"%@\"", __key_id];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTGetPublicKey_result : NSObject <TBase, NSCoding> {
  LYRTPublicKey * __success;
  LYRTNotFoundException * __nfException;
  LYRTInternalException * __intException;

  BOOL __success_isset;
  BOOL __nfException_isset;
  BOOL __intException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) LYRTPublicKey * success;
@property (nonatomic, retain, getter=nfException, setter=setNfException:) LYRTNotFoundException * nfException;
@property (nonatomic, retain, getter=intException, setter=setIntException:) LYRTInternalException * intException;
#endif

- (id) init;
- (id) initWithSuccess: (LYRTPublicKey *) success nfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTPublicKey *) success;
- (void) setSuccess: (LYRTPublicKey *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (LYRTNotFoundException *) nfException;
- (void) setNfException: (LYRTNotFoundException *) nfException;
#endif
- (BOOL) nfExceptionIsSet;

#if !__has_feature(objc_arc)
- (LYRTInternalException *) intException;
- (void) setIntException: (LYRTInternalException *) intException;
#endif
- (BOOL) intExceptionIsSet;

@end

@implementation LYRTGetPublicKey_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (LYRTPublicKey *) success nfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __nfException = [nfException retain_stub];
  __nfException_isset = YES;
  __intException = [intException retain_stub];
  __intException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"nfException"])
  {
    __nfException = [[decoder decodeObjectForKey: @"nfException"] retain_stub];
    __nfException_isset = YES;
  }
  if ([decoder containsValueForKey: @"intException"])
  {
    __intException = [[decoder decodeObjectForKey: @"intException"] retain_stub];
    __intException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__nfException_isset)
  {
    [encoder encodeObject: __nfException forKey: @"nfException"];
  }
  if (__intException_isset)
  {
    [encoder encodeObject: __intException forKey: @"intException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__nfException release_stub];
  [__intException release_stub];
  [super dealloc_stub];
}

- (LYRTPublicKey *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (LYRTPublicKey *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (LYRTNotFoundException *) nfException {
  return [[__nfException retain_stub] autorelease_stub];
}

- (void) setNfException: (LYRTNotFoundException *) nfException {
  [nfException retain_stub];
  [__nfException release_stub];
  __nfException = nfException;
  __nfException_isset = YES;
}

- (BOOL) nfExceptionIsSet {
  return __nfException_isset;
}

- (void) unsetNfException {
  [__nfException release_stub];
  __nfException = nil;
  __nfException_isset = NO;
}

- (LYRTInternalException *) intException {
  return [[__intException retain_stub] autorelease_stub];
}

- (void) setIntException: (LYRTInternalException *) intException {
  [intException retain_stub];
  [__intException release_stub];
  __intException = intException;
  __intException_isset = YES;
}

- (BOOL) intExceptionIsSet {
  return __intException_isset;
}

- (void) unsetIntException {
  [__intException release_stub];
  __intException = nil;
  __intException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          LYRTPublicKey *fieldValue = [[LYRTPublicKey alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTNotFoundException *fieldValue = [[LYRTNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNfException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          LYRTInternalException *fieldValue = [[LYRTInternalException alloc] init];
          [fieldValue read: inProtocol];
          [self setIntException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetPublicKey_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__nfException_isset) {
    if (__nfException != nil) {
      [outProtocol writeFieldBeginWithName: @"nfException" type: TType_STRUCT fieldID: 1];
      [__nfException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__intException_isset) {
    if (__intException != nil) {
      [outProtocol writeFieldBeginWithName: @"intException" type: TType_STRUCT fieldID: 2];
      [__intException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetPublicKey_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",nfException:"];
  [ms appendFormat: @"%@", __nfException];
  [ms appendString: @",intException:"];
  [ms appendFormat: @"%@", __intException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTgetAllPublicKeys_args : NSObject <TBase, NSCoding> {
  LYRTUUID __provider_id;

  BOOL __provider_id_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=provider_id, setter=setProvider_id:) LYRTUUID provider_id;
#endif

- (id) init;
- (id) initWithProvider_id: (LYRTUUID) provider_id;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTUUID) provider_id;
- (void) setProvider_id: (LYRTUUID) provider_id;
#endif
- (BOOL) provider_idIsSet;

@end

@implementation LYRTgetAllPublicKeys_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithProvider_id: (LYRTUUID) provider_id
{
  self = [super init];
  __provider_id = [provider_id retain_stub];
  __provider_id_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"provider_id"])
  {
    __provider_id = [[decoder decodeObjectForKey: @"provider_id"] retain_stub];
    __provider_id_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__provider_id_isset)
  {
    [encoder encodeObject: __provider_id forKey: @"provider_id"];
  }
}

- (void) dealloc
{
  [__provider_id release_stub];
  [super dealloc_stub];
}

- (NSData *) provider_id {
  return [[__provider_id retain_stub] autorelease_stub];
}

- (void) setProvider_id: (NSData *) provider_id {
  [provider_id retain_stub];
  [__provider_id release_stub];
  __provider_id = provider_id;
  __provider_id_isset = YES;
}

- (BOOL) provider_idIsSet {
  return __provider_id_isset;
}

- (void) unsetProvider_id {
  [__provider_id release_stub];
  __provider_id = nil;
  __provider_id_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setProvider_id: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getAllPublicKeys_args"];
  if (__provider_id_isset) {
    if (__provider_id != nil) {
      [outProtocol writeFieldBeginWithName: @"provider_id" type: TType_STRING fieldID: 1];
      [outProtocol writeBinary: __provider_id];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getAllPublicKeys_args("];
  [ms appendString: @"provider_id:"];
  [ms appendFormat: @"\"%@\"", __provider_id];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTGetAllPublicKeys_result : NSObject <TBase, NSCoding> {
  NSMutableArray * __success;
  LYRTNotFoundException * __nfException;
  LYRTInternalException * __intException;

  BOOL __success_isset;
  BOOL __nfException_isset;
  BOOL __intException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSMutableArray * success;
@property (nonatomic, retain, getter=nfException, setter=setNfException:) LYRTNotFoundException * nfException;
@property (nonatomic, retain, getter=intException, setter=setIntException:) LYRTInternalException * intException;
#endif

- (id) init;
- (id) initWithSuccess: (NSMutableArray *) success nfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (NSMutableArray *) success;
- (void) setSuccess: (NSMutableArray *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (LYRTNotFoundException *) nfException;
- (void) setNfException: (LYRTNotFoundException *) nfException;
#endif
- (BOOL) nfExceptionIsSet;

#if !__has_feature(objc_arc)
- (LYRTInternalException *) intException;
- (void) setIntException: (LYRTInternalException *) intException;
#endif
- (BOOL) intExceptionIsSet;

@end

@implementation LYRTGetAllPublicKeys_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (NSMutableArray *) success nfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __nfException = [nfException retain_stub];
  __nfException_isset = YES;
  __intException = [intException retain_stub];
  __intException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"nfException"])
  {
    __nfException = [[decoder decodeObjectForKey: @"nfException"] retain_stub];
    __nfException_isset = YES;
  }
  if ([decoder containsValueForKey: @"intException"])
  {
    __intException = [[decoder decodeObjectForKey: @"intException"] retain_stub];
    __intException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__nfException_isset)
  {
    [encoder encodeObject: __nfException forKey: @"nfException"];
  }
  if (__intException_isset)
  {
    [encoder encodeObject: __intException forKey: @"intException"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__nfException release_stub];
  [__intException release_stub];
  [super dealloc_stub];
}

- (NSMutableArray *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (NSMutableArray *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (LYRTNotFoundException *) nfException {
  return [[__nfException retain_stub] autorelease_stub];
}

- (void) setNfException: (LYRTNotFoundException *) nfException {
  [nfException retain_stub];
  [__nfException release_stub];
  __nfException = nfException;
  __nfException_isset = YES;
}

- (BOOL) nfExceptionIsSet {
  return __nfException_isset;
}

- (void) unsetNfException {
  [__nfException release_stub];
  __nfException = nil;
  __nfException_isset = NO;
}

- (LYRTInternalException *) intException {
  return [[__intException retain_stub] autorelease_stub];
}

- (void) setIntException: (LYRTInternalException *) intException {
  [intException retain_stub];
  [__intException release_stub];
  __intException = intException;
  __intException_isset = YES;
}

- (BOOL) intExceptionIsSet {
  return __intException_isset;
}

- (void) unsetIntException {
  [__intException release_stub];
  __intException = nil;
  __intException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size20;
          [inProtocol readListBeginReturningElementType: NULL size: &_size20];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size20];
          int _i21;
          for (_i21 = 0; _i21 < _size20; ++_i21)
          {
            LYRTPublicKey *_elem22 = [[LYRTPublicKey alloc] init];
            [_elem22 read: inProtocol];
            [fieldValue addObject: _elem22];
            [_elem22 release_stub];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTNotFoundException *fieldValue = [[LYRTNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNfException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          LYRTInternalException *fieldValue = [[LYRTInternalException alloc] init];
          [fieldValue read: inProtocol];
          [self setIntException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetAllPublicKeys_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        int i24;
        for (i24 = 0; i24 < [__success count]; i24++)
        {
          [[__success objectAtIndex: i24] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__nfException_isset) {
    if (__nfException != nil) {
      [outProtocol writeFieldBeginWithName: @"nfException" type: TType_STRUCT fieldID: 1];
      [__nfException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__intException_isset) {
    if (__intException != nil) {
      [outProtocol writeFieldBeginWithName: @"intException" type: TType_STRUCT fieldID: 2];
      [__intException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetAllPublicKeys_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",nfException:"];
  [ms appendFormat: @"%@", __nfException];
  [ms appendString: @",intException:"];
  [ms appendFormat: @"%@", __intException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTupdatePublicKey_args : NSObject <TBase, NSCoding> {
  LYRTPublicKey * __public_key;

  BOOL __public_key_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=public_key, setter=setPublic_key:) LYRTPublicKey * public_key;
#endif

- (id) init;
- (id) initWithPublic_key: (LYRTPublicKey *) public_key;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTPublicKey *) public_key;
- (void) setPublic_key: (LYRTPublicKey *) public_key;
#endif
- (BOOL) public_keyIsSet;

@end

@implementation LYRTupdatePublicKey_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithPublic_key: (LYRTPublicKey *) public_key
{
  self = [super init];
  __public_key = [public_key retain_stub];
  __public_key_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"public_key"])
  {
    __public_key = [[decoder decodeObjectForKey: @"public_key"] retain_stub];
    __public_key_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__public_key_isset)
  {
    [encoder encodeObject: __public_key forKey: @"public_key"];
  }
}

- (void) dealloc
{
  [__public_key release_stub];
  [super dealloc_stub];
}

- (LYRTPublicKey *) public_key {
  return [[__public_key retain_stub] autorelease_stub];
}

- (void) setPublic_key: (LYRTPublicKey *) public_key {
  [public_key retain_stub];
  [__public_key release_stub];
  __public_key = public_key;
  __public_key_isset = YES;
}

- (BOOL) public_keyIsSet {
  return __public_key_isset;
}

- (void) unsetPublic_key {
  [__public_key release_stub];
  __public_key = nil;
  __public_key_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTPublicKey *fieldValue = [[LYRTPublicKey alloc] init];
          [fieldValue read: inProtocol];
          [self setPublic_key: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"updatePublicKey_args"];
  if (__public_key_isset) {
    if (__public_key != nil) {
      [outProtocol writeFieldBeginWithName: @"public_key" type: TType_STRUCT fieldID: 1];
      [__public_key write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"updatePublicKey_args("];
  [ms appendString: @"public_key:"];
  [ms appendFormat: @"%@", __public_key];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTUpdatePublicKey_result : NSObject <TBase, NSCoding> {
  LYRTNotFoundException * __nfException;
  LYRTInternalException * __intException;

  BOOL __nfException_isset;
  BOOL __intException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=nfException, setter=setNfException:) LYRTNotFoundException * nfException;
@property (nonatomic, retain, getter=intException, setter=setIntException:) LYRTInternalException * intException;
#endif

- (id) init;
- (id) initWithNfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTNotFoundException *) nfException;
- (void) setNfException: (LYRTNotFoundException *) nfException;
#endif
- (BOOL) nfExceptionIsSet;

#if !__has_feature(objc_arc)
- (LYRTInternalException *) intException;
- (void) setIntException: (LYRTInternalException *) intException;
#endif
- (BOOL) intExceptionIsSet;

@end

@implementation LYRTUpdatePublicKey_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithNfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException
{
  self = [super init];
  __nfException = [nfException retain_stub];
  __nfException_isset = YES;
  __intException = [intException retain_stub];
  __intException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"nfException"])
  {
    __nfException = [[decoder decodeObjectForKey: @"nfException"] retain_stub];
    __nfException_isset = YES;
  }
  if ([decoder containsValueForKey: @"intException"])
  {
    __intException = [[decoder decodeObjectForKey: @"intException"] retain_stub];
    __intException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__nfException_isset)
  {
    [encoder encodeObject: __nfException forKey: @"nfException"];
  }
  if (__intException_isset)
  {
    [encoder encodeObject: __intException forKey: @"intException"];
  }
}

- (void) dealloc
{
  [__nfException release_stub];
  [__intException release_stub];
  [super dealloc_stub];
}

- (LYRTNotFoundException *) nfException {
  return [[__nfException retain_stub] autorelease_stub];
}

- (void) setNfException: (LYRTNotFoundException *) nfException {
  [nfException retain_stub];
  [__nfException release_stub];
  __nfException = nfException;
  __nfException_isset = YES;
}

- (BOOL) nfExceptionIsSet {
  return __nfException_isset;
}

- (void) unsetNfException {
  [__nfException release_stub];
  __nfException = nil;
  __nfException_isset = NO;
}

- (LYRTInternalException *) intException {
  return [[__intException retain_stub] autorelease_stub];
}

- (void) setIntException: (LYRTInternalException *) intException {
  [intException retain_stub];
  [__intException release_stub];
  __intException = intException;
  __intException_isset = YES;
}

- (BOOL) intExceptionIsSet {
  return __intException_isset;
}

- (void) unsetIntException {
  [__intException release_stub];
  __intException = nil;
  __intException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTNotFoundException *fieldValue = [[LYRTNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNfException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          LYRTInternalException *fieldValue = [[LYRTInternalException alloc] init];
          [fieldValue read: inProtocol];
          [self setIntException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UpdatePublicKey_result"];

  if (__nfException_isset) {
    if (__nfException != nil) {
      [outProtocol writeFieldBeginWithName: @"nfException" type: TType_STRUCT fieldID: 1];
      [__nfException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__intException_isset) {
    if (__intException != nil) {
      [outProtocol writeFieldBeginWithName: @"intException" type: TType_STRUCT fieldID: 2];
      [__intException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UpdatePublicKey_result("];
  [ms appendString: @"nfException:"];
  [ms appendFormat: @"%@", __nfException];
  [ms appendString: @",intException:"];
  [ms appendFormat: @"%@", __intException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTtoggleUserBlacklist_args : NSObject <TBase, NSCoding> {
  LYRTUUID __app_id;
  LYRTUUID __user_id;
  BOOL __blacklisted;

  BOOL __app_id_isset;
  BOOL __user_id_isset;
  BOOL __blacklisted_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=app_id, setter=setApp_id:) LYRTUUID app_id;
@property (nonatomic, retain, getter=user_id, setter=setUser_id:) LYRTUUID user_id;
@property (nonatomic, getter=blacklisted, setter=setBlacklisted:) BOOL blacklisted;
#endif

- (id) init;
- (id) initWithApp_id: (LYRTUUID) app_id user_id: (LYRTUUID) user_id blacklisted: (BOOL) blacklisted;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTUUID) app_id;
- (void) setApp_id: (LYRTUUID) app_id;
#endif
- (BOOL) app_idIsSet;

#if !__has_feature(objc_arc)
- (LYRTUUID) user_id;
- (void) setUser_id: (LYRTUUID) user_id;
#endif
- (BOOL) user_idIsSet;

#if !__has_feature(objc_arc)
- (BOOL) blacklisted;
- (void) setBlacklisted: (BOOL) blacklisted;
#endif
- (BOOL) blacklistedIsSet;

@end

@implementation LYRTtoggleUserBlacklist_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithApp_id: (LYRTUUID) app_id user_id: (LYRTUUID) user_id blacklisted: (BOOL) blacklisted
{
  self = [super init];
  __app_id = [app_id retain_stub];
  __app_id_isset = YES;
  __user_id = [user_id retain_stub];
  __user_id_isset = YES;
  __blacklisted = blacklisted;
  __blacklisted_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"app_id"])
  {
    __app_id = [[decoder decodeObjectForKey: @"app_id"] retain_stub];
    __app_id_isset = YES;
  }
  if ([decoder containsValueForKey: @"user_id"])
  {
    __user_id = [[decoder decodeObjectForKey: @"user_id"] retain_stub];
    __user_id_isset = YES;
  }
  if ([decoder containsValueForKey: @"blacklisted"])
  {
    __blacklisted = [decoder decodeBoolForKey: @"blacklisted"];
    __blacklisted_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__app_id_isset)
  {
    [encoder encodeObject: __app_id forKey: @"app_id"];
  }
  if (__user_id_isset)
  {
    [encoder encodeObject: __user_id forKey: @"user_id"];
  }
  if (__blacklisted_isset)
  {
    [encoder encodeBool: __blacklisted forKey: @"blacklisted"];
  }
}

- (void) dealloc
{
  [__app_id release_stub];
  [__user_id release_stub];
  [super dealloc_stub];
}

- (NSData *) app_id {
  return [[__app_id retain_stub] autorelease_stub];
}

- (void) setApp_id: (NSData *) app_id {
  [app_id retain_stub];
  [__app_id release_stub];
  __app_id = app_id;
  __app_id_isset = YES;
}

- (BOOL) app_idIsSet {
  return __app_id_isset;
}

- (void) unsetApp_id {
  [__app_id release_stub];
  __app_id = nil;
  __app_id_isset = NO;
}

- (NSData *) user_id {
  return [[__user_id retain_stub] autorelease_stub];
}

- (void) setUser_id: (NSData *) user_id {
  [user_id retain_stub];
  [__user_id release_stub];
  __user_id = user_id;
  __user_id_isset = YES;
}

- (BOOL) user_idIsSet {
  return __user_id_isset;
}

- (void) unsetUser_id {
  [__user_id release_stub];
  __user_id = nil;
  __user_id_isset = NO;
}

- (BOOL) blacklisted {
  return __blacklisted;
}

- (void) setBlacklisted: (BOOL) blacklisted {
  __blacklisted = blacklisted;
  __blacklisted_isset = YES;
}

- (BOOL) blacklistedIsSet {
  return __blacklisted_isset;
}

- (void) unsetBlacklisted {
  __blacklisted_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setApp_id: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setUser_id: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setBlacklisted: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"toggleUserBlacklist_args"];
  if (__app_id_isset) {
    if (__app_id != nil) {
      [outProtocol writeFieldBeginWithName: @"app_id" type: TType_STRING fieldID: 1];
      [outProtocol writeBinary: __app_id];
      [outProtocol writeFieldEnd];
    }
  }
  if (__user_id_isset) {
    if (__user_id != nil) {
      [outProtocol writeFieldBeginWithName: @"user_id" type: TType_STRING fieldID: 2];
      [outProtocol writeBinary: __user_id];
      [outProtocol writeFieldEnd];
    }
  }
  if (__blacklisted_isset) {
    [outProtocol writeFieldBeginWithName: @"blacklisted" type: TType_BOOL fieldID: 3];
    [outProtocol writeBool: __blacklisted];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"toggleUserBlacklist_args("];
  [ms appendString: @"app_id:"];
  [ms appendFormat: @"\"%@\"", __app_id];
  [ms appendString: @",user_id:"];
  [ms appendFormat: @"\"%@\"", __user_id];
  [ms appendString: @",blacklisted:"];
  [ms appendFormat: @"%i", __blacklisted];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTToggleUserBlacklist_result : NSObject <TBase, NSCoding> {
  BOOL __success;
  LYRTNotFoundException * __nfException;
  LYRTInternalException * __intException;

  BOOL __success_isset;
  BOOL __nfException_isset;
  BOOL __intException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) BOOL success;
@property (nonatomic, retain, getter=nfException, setter=setNfException:) LYRTNotFoundException * nfException;
@property (nonatomic, retain, getter=intException, setter=setIntException:) LYRTInternalException * intException;
#endif

- (id) init;
- (id) initWithSuccess: (BOOL) success nfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (BOOL) success;
- (void) setSuccess: (BOOL) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (LYRTNotFoundException *) nfException;
- (void) setNfException: (LYRTNotFoundException *) nfException;
#endif
- (BOOL) nfExceptionIsSet;

#if !__has_feature(objc_arc)
- (LYRTInternalException *) intException;
- (void) setIntException: (LYRTInternalException *) intException;
#endif
- (BOOL) intExceptionIsSet;

@end

@implementation LYRTToggleUserBlacklist_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (BOOL) success nfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __nfException = [nfException retain_stub];
  __nfException_isset = YES;
  __intException = [intException retain_stub];
  __intException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeBoolForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"nfException"])
  {
    __nfException = [[decoder decodeObjectForKey: @"nfException"] retain_stub];
    __nfException_isset = YES;
  }
  if ([decoder containsValueForKey: @"intException"])
  {
    __intException = [[decoder decodeObjectForKey: @"intException"] retain_stub];
    __intException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeBool: __success forKey: @"success"];
  }
  if (__nfException_isset)
  {
    [encoder encodeObject: __nfException forKey: @"nfException"];
  }
  if (__intException_isset)
  {
    [encoder encodeObject: __intException forKey: @"intException"];
  }
}

- (void) dealloc
{
  [__nfException release_stub];
  [__intException release_stub];
  [super dealloc_stub];
}

- (BOOL) success {
  return __success;
}

- (void) setSuccess: (BOOL) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (LYRTNotFoundException *) nfException {
  return [[__nfException retain_stub] autorelease_stub];
}

- (void) setNfException: (LYRTNotFoundException *) nfException {
  [nfException retain_stub];
  [__nfException release_stub];
  __nfException = nfException;
  __nfException_isset = YES;
}

- (BOOL) nfExceptionIsSet {
  return __nfException_isset;
}

- (void) unsetNfException {
  [__nfException release_stub];
  __nfException = nil;
  __nfException_isset = NO;
}

- (LYRTInternalException *) intException {
  return [[__intException retain_stub] autorelease_stub];
}

- (void) setIntException: (LYRTInternalException *) intException {
  [intException retain_stub];
  [__intException release_stub];
  __intException = intException;
  __intException_isset = YES;
}

- (BOOL) intExceptionIsSet {
  return __intException_isset;
}

- (void) unsetIntException {
  [__intException release_stub];
  __intException = nil;
  __intException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTNotFoundException *fieldValue = [[LYRTNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNfException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          LYRTInternalException *fieldValue = [[LYRTInternalException alloc] init];
          [fieldValue read: inProtocol];
          [self setIntException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ToggleUserBlacklist_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_BOOL fieldID: 0];
    [outProtocol writeBool: __success];
    [outProtocol writeFieldEnd];
  } else if (__nfException_isset) {
    if (__nfException != nil) {
      [outProtocol writeFieldBeginWithName: @"nfException" type: TType_STRUCT fieldID: 1];
      [__nfException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__intException_isset) {
    if (__intException != nil) {
      [outProtocol writeFieldBeginWithName: @"intException" type: TType_STRUCT fieldID: 2];
      [__intException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ToggleUserBlacklist_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",nfException:"];
  [ms appendFormat: @"%@", __nfException];
  [ms appendString: @",intException:"];
  [ms appendFormat: @"%@", __intException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTrevokeSession_args : NSObject <TBase, NSCoding> {
  LYRTUUID __app_id;
  LYRTUUID __user_id;

  BOOL __app_id_isset;
  BOOL __user_id_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=app_id, setter=setApp_id:) LYRTUUID app_id;
@property (nonatomic, retain, getter=user_id, setter=setUser_id:) LYRTUUID user_id;
#endif

- (id) init;
- (id) initWithApp_id: (LYRTUUID) app_id user_id: (LYRTUUID) user_id;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTUUID) app_id;
- (void) setApp_id: (LYRTUUID) app_id;
#endif
- (BOOL) app_idIsSet;

#if !__has_feature(objc_arc)
- (LYRTUUID) user_id;
- (void) setUser_id: (LYRTUUID) user_id;
#endif
- (BOOL) user_idIsSet;

@end

@implementation LYRTrevokeSession_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithApp_id: (LYRTUUID) app_id user_id: (LYRTUUID) user_id
{
  self = [super init];
  __app_id = [app_id retain_stub];
  __app_id_isset = YES;
  __user_id = [user_id retain_stub];
  __user_id_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"app_id"])
  {
    __app_id = [[decoder decodeObjectForKey: @"app_id"] retain_stub];
    __app_id_isset = YES;
  }
  if ([decoder containsValueForKey: @"user_id"])
  {
    __user_id = [[decoder decodeObjectForKey: @"user_id"] retain_stub];
    __user_id_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__app_id_isset)
  {
    [encoder encodeObject: __app_id forKey: @"app_id"];
  }
  if (__user_id_isset)
  {
    [encoder encodeObject: __user_id forKey: @"user_id"];
  }
}

- (void) dealloc
{
  [__app_id release_stub];
  [__user_id release_stub];
  [super dealloc_stub];
}

- (NSData *) app_id {
  return [[__app_id retain_stub] autorelease_stub];
}

- (void) setApp_id: (NSData *) app_id {
  [app_id retain_stub];
  [__app_id release_stub];
  __app_id = app_id;
  __app_id_isset = YES;
}

- (BOOL) app_idIsSet {
  return __app_id_isset;
}

- (void) unsetApp_id {
  [__app_id release_stub];
  __app_id = nil;
  __app_id_isset = NO;
}

- (NSData *) user_id {
  return [[__user_id retain_stub] autorelease_stub];
}

- (void) setUser_id: (NSData *) user_id {
  [user_id retain_stub];
  [__user_id release_stub];
  __user_id = user_id;
  __user_id_isset = YES;
}

- (BOOL) user_idIsSet {
  return __user_id_isset;
}

- (void) unsetUser_id {
  [__user_id release_stub];
  __user_id = nil;
  __user_id_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setApp_id: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setUser_id: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"revokeSession_args"];
  if (__app_id_isset) {
    if (__app_id != nil) {
      [outProtocol writeFieldBeginWithName: @"app_id" type: TType_STRING fieldID: 1];
      [outProtocol writeBinary: __app_id];
      [outProtocol writeFieldEnd];
    }
  }
  if (__user_id_isset) {
    if (__user_id != nil) {
      [outProtocol writeFieldBeginWithName: @"user_id" type: TType_STRING fieldID: 2];
      [outProtocol writeBinary: __user_id];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"revokeSession_args("];
  [ms appendString: @"app_id:"];
  [ms appendFormat: @"\"%@\"", __app_id];
  [ms appendString: @",user_id:"];
  [ms appendFormat: @"\"%@\"", __user_id];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTRevokeSession_result : NSObject <TBase, NSCoding> {
  LYRTNotFoundException * __nfException;
  LYRTInternalException * __intException;

  BOOL __nfException_isset;
  BOOL __intException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=nfException, setter=setNfException:) LYRTNotFoundException * nfException;
@property (nonatomic, retain, getter=intException, setter=setIntException:) LYRTInternalException * intException;
#endif

- (id) init;
- (id) initWithNfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (LYRTNotFoundException *) nfException;
- (void) setNfException: (LYRTNotFoundException *) nfException;
#endif
- (BOOL) nfExceptionIsSet;

#if !__has_feature(objc_arc)
- (LYRTInternalException *) intException;
- (void) setIntException: (LYRTInternalException *) intException;
#endif
- (BOOL) intExceptionIsSet;

@end

@implementation LYRTRevokeSession_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithNfException: (LYRTNotFoundException *) nfException intException: (LYRTInternalException *) intException
{
  self = [super init];
  __nfException = [nfException retain_stub];
  __nfException_isset = YES;
  __intException = [intException retain_stub];
  __intException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"nfException"])
  {
    __nfException = [[decoder decodeObjectForKey: @"nfException"] retain_stub];
    __nfException_isset = YES;
  }
  if ([decoder containsValueForKey: @"intException"])
  {
    __intException = [[decoder decodeObjectForKey: @"intException"] retain_stub];
    __intException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__nfException_isset)
  {
    [encoder encodeObject: __nfException forKey: @"nfException"];
  }
  if (__intException_isset)
  {
    [encoder encodeObject: __intException forKey: @"intException"];
  }
}

- (void) dealloc
{
  [__nfException release_stub];
  [__intException release_stub];
  [super dealloc_stub];
}

- (LYRTNotFoundException *) nfException {
  return [[__nfException retain_stub] autorelease_stub];
}

- (void) setNfException: (LYRTNotFoundException *) nfException {
  [nfException retain_stub];
  [__nfException release_stub];
  __nfException = nfException;
  __nfException_isset = YES;
}

- (BOOL) nfExceptionIsSet {
  return __nfException_isset;
}

- (void) unsetNfException {
  [__nfException release_stub];
  __nfException = nil;
  __nfException_isset = NO;
}

- (LYRTInternalException *) intException {
  return [[__intException retain_stub] autorelease_stub];
}

- (void) setIntException: (LYRTInternalException *) intException {
  [intException retain_stub];
  [__intException release_stub];
  __intException = intException;
  __intException_isset = YES;
}

- (BOOL) intExceptionIsSet {
  return __intException_isset;
}

- (void) unsetIntException {
  [__intException release_stub];
  __intException = nil;
  __intException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          LYRTNotFoundException *fieldValue = [[LYRTNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNfException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          LYRTInternalException *fieldValue = [[LYRTInternalException alloc] init];
          [fieldValue read: inProtocol];
          [self setIntException: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"RevokeSession_result"];

  if (__nfException_isset) {
    if (__nfException != nil) {
      [outProtocol writeFieldBeginWithName: @"nfException" type: TType_STRUCT fieldID: 1];
      [__nfException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__intException_isset) {
    if (__intException != nil) {
      [outProtocol writeFieldBeginWithName: @"intException" type: TType_STRUCT fieldID: 2];
      [__intException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"RevokeSession_result("];
  [ms appendString: @"nfException:"];
  [ms appendFormat: @"%@", __nfException];
  [ms appendString: @",intException:"];
  [ms appendFormat: @"%@", __intException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTping_args : NSObject <TBase, NSCoding> {
  NSString * __ping;

  BOOL __ping_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=ping, setter=setPing:) NSString * ping;
#endif

- (id) init;
- (id) initWithPing: (NSString *) ping;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (NSString *) ping;
- (void) setPing: (NSString *) ping;
#endif
- (BOOL) pingIsSet;

@end

@implementation LYRTping_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithPing: (NSString *) ping
{
  self = [super init];
  __ping = [ping retain_stub];
  __ping_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"ping"])
  {
    __ping = [[decoder decodeObjectForKey: @"ping"] retain_stub];
    __ping_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__ping_isset)
  {
    [encoder encodeObject: __ping forKey: @"ping"];
  }
}

- (void) dealloc
{
  [__ping release_stub];
  [super dealloc_stub];
}

- (NSString *) ping {
  return [[__ping retain_stub] autorelease_stub];
}

- (void) setPing: (NSString *) ping {
  [ping retain_stub];
  [__ping release_stub];
  __ping = ping;
  __ping_isset = YES;
}

- (BOOL) pingIsSet {
  return __ping_isset;
}

- (void) unsetPing {
  [__ping release_stub];
  __ping = nil;
  __ping_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setPing: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ping_args"];
  if (__ping_isset) {
    if (__ping != nil) {
      [outProtocol writeFieldBeginWithName: @"ping" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __ping];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ping_args("];
  [ms appendString: @"ping:"];
  [ms appendFormat: @"\"%@\"", __ping];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface LYRTPing_result : NSObject <TBase, NSCoding> {
  NSString * __success;

  BOOL __success_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSString * success;
#endif

- (id) init;
- (id) initWithSuccess: (NSString *) success;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (NSString *) success;
- (void) setSuccess: (NSString *) success;
#endif
- (BOOL) successIsSet;

@end

@implementation LYRTPing_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (NSString *) success
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [super dealloc_stub];
}

- (NSString *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (NSString *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Ping_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Ping_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation LYRTCtrlClient
- (id) initWithProtocol: (id <TProtocol>) protocol
{
  return [self initWithInProtocol: protocol outProtocol: protocol];
}

- (id) initWithInProtocol: (id <TProtocol>) anInProtocol outProtocol: (id <TProtocol>) anOutProtocol
{
  self = [super init];
  inProtocol = [anInProtocol retain_stub];
  outProtocol = [anOutProtocol retain_stub];
  return self;
}

- (void) dealloc
{
  [inProtocol release_stub];
  [outProtocol release_stub];
  [super dealloc_stub];
}

- (void) send_createAccount: (LYRTAccount *) account
{
  [outProtocol writeMessageBeginWithName: @"createAccount" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"createAccount_args"];
  if (account != nil)  {
    [outProtocol writeFieldBeginWithName: @"account" type: TType_STRUCT fieldID: 1];
    [account write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (LYRTAccount *) recv_createAccount
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  LYRTCreateAccount_result * result = [[[LYRTCreateAccount_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result intExceptionIsSet]) {
    @throw [result intException];
  }
  if ([result brExceptionIsSet]) {
    @throw [result brException];
  }
  if ([result cfExceptionIsSet]) {
    @throw [result cfException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"createAccount failed: unknown result"];
}

- (LYRTAccount *) createAccount: (LYRTAccount *) account
{
  [self send_createAccount : account];
  return [self recv_createAccount];
}

- (void) send_getAccount: (LYRTUUID) id
{
  [outProtocol writeMessageBeginWithName: @"getAccount" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getAccount_args"];
  if (id != nil)  {
    [outProtocol writeFieldBeginWithName: @"id" type: TType_STRING fieldID: 1];
    [outProtocol writeBinary: id];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (LYRTAccount *) recv_getAccount
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  LYRTGetAccount_result * result = [[[LYRTGetAccount_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result nfExceptionIsSet]) {
    @throw [result nfException];
  }
  if ([result intExceptionIsSet]) {
    @throw [result intException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getAccount failed: unknown result"];
}

- (LYRTAccount *) getAccount: (LYRTUUID) id
{
  [self send_getAccount : id];
  return [self recv_getAccount];
}

- (void) send_updateAccount: (LYRTAccount *) account
{
  [outProtocol writeMessageBeginWithName: @"updateAccount" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"updateAccount_args"];
  if (account != nil)  {
    [outProtocol writeFieldBeginWithName: @"account" type: TType_STRUCT fieldID: 1];
    [account write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (void) recv_updateAccount
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  LYRTUpdateAccount_result * result = [[[LYRTUpdateAccount_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result nfExceptionIsSet]) {
    @throw [result nfException];
  }
  if ([result intExceptionIsSet]) {
    @throw [result intException];
  }
  if ([result cfExceptionIsSet]) {
    @throw [result cfException];
  }
  return;
}

- (void) updateAccount: (LYRTAccount *) account
{
  [self send_updateAccount : account];
  [self recv_updateAccount];
}

- (void) send_login: (NSString *) email password: (NSString *) password
{
  [outProtocol writeMessageBeginWithName: @"login" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"login_args"];
  if (email != nil)  {
    [outProtocol writeFieldBeginWithName: @"email" type: TType_STRING fieldID: 1];
    [outProtocol writeString: email];
    [outProtocol writeFieldEnd];
  }
  if (password != nil)  {
    [outProtocol writeFieldBeginWithName: @"password" type: TType_STRING fieldID: 2];
    [outProtocol writeString: password];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (LYRTAccount *) recv_login
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  LYRTLogin_result * result = [[[LYRTLogin_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result nfExceptionIsSet]) {
    @throw [result nfException];
  }
  if ([result uaExceptionIsSet]) {
    @throw [result uaException];
  }
  if ([result intExceptionIsSet]) {
    @throw [result intException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"login failed: unknown result"];
}

- (LYRTAccount *) login: (NSString *) email password: (NSString *) password
{
  [self send_login : email password: password];
  return [self recv_login];
}

- (void) send_resetPassword: (LYRTUUID) id old_password: (NSString *) old_password new_password: (NSString *) new_password
{
  [outProtocol writeMessageBeginWithName: @"resetPassword" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"resetPassword_args"];
  if (id != nil)  {
    [outProtocol writeFieldBeginWithName: @"id" type: TType_STRING fieldID: 1];
    [outProtocol writeBinary: id];
    [outProtocol writeFieldEnd];
  }
  if (old_password != nil)  {
    [outProtocol writeFieldBeginWithName: @"old_password" type: TType_STRING fieldID: 2];
    [outProtocol writeString: old_password];
    [outProtocol writeFieldEnd];
  }
  if (new_password != nil)  {
    [outProtocol writeFieldBeginWithName: @"new_password" type: TType_STRING fieldID: 3];
    [outProtocol writeString: new_password];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (void) recv_resetPassword
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  LYRTResetPassword_result * result = [[[LYRTResetPassword_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result nfExceptionIsSet]) {
    @throw [result nfException];
  }
  if ([result uaExceptionIsSet]) {
    @throw [result uaException];
  }
  if ([result intExceptionIsSet]) {
    @throw [result intException];
  }
  return;
}

- (void) resetPassword: (LYRTUUID) id old_password: (NSString *) old_password new_password: (NSString *) new_password
{
  [self send_resetPassword : id old_password: old_password new_password: new_password];
  [self recv_resetPassword];
}

- (void) send_forceResetPassword: (LYRTUUID) id new_password: (NSString *) new_password
{
  [outProtocol writeMessageBeginWithName: @"forceResetPassword" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"forceResetPassword_args"];
  if (id != nil)  {
    [outProtocol writeFieldBeginWithName: @"id" type: TType_STRING fieldID: 1];
    [outProtocol writeBinary: id];
    [outProtocol writeFieldEnd];
  }
  if (new_password != nil)  {
    [outProtocol writeFieldBeginWithName: @"new_password" type: TType_STRING fieldID: 2];
    [outProtocol writeString: new_password];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (void) recv_forceResetPassword
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  LYRTForceResetPassword_result * result = [[[LYRTForceResetPassword_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result nfExceptionIsSet]) {
    @throw [result nfException];
  }
  if ([result uaExceptionIsSet]) {
    @throw [result uaException];
  }
  if ([result intExceptionIsSet]) {
    @throw [result intException];
  }
  return;
}

- (void) forceResetPassword: (LYRTUUID) id new_password: (NSString *) new_password
{
  [self send_forceResetPassword : id new_password: new_password];
  [self recv_forceResetPassword];
}

- (void) send_getAccountByEmail: (NSString *) email
{
  [outProtocol writeMessageBeginWithName: @"getAccountByEmail" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getAccountByEmail_args"];
  if (email != nil)  {
    [outProtocol writeFieldBeginWithName: @"email" type: TType_STRING fieldID: 1];
    [outProtocol writeString: email];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (LYRTAccount *) recv_getAccountByEmail
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  LYRTGetAccountByEmail_result * result = [[[LYRTGetAccountByEmail_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result nfExceptionIsSet]) {
    @throw [result nfException];
  }
  if ([result intExceptionIsSet]) {
    @throw [result intException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getAccountByEmail failed: unknown result"];
}

- (LYRTAccount *) getAccountByEmail: (NSString *) email
{
  [self send_getAccountByEmail : email];
  return [self recv_getAccountByEmail];
}

- (void) send_getAllAccounts
{
  [outProtocol writeMessageBeginWithName: @"getAllAccounts" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getAllAccounts_args"];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (LYRTAccounts) recv_getAllAccounts
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  LYRTGetAllAccounts_result * result = [[[LYRTGetAllAccounts_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result nfExceptionIsSet]) {
    @throw [result nfException];
  }
  if ([result intExceptionIsSet]) {
    @throw [result intException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getAllAccounts failed: unknown result"];
}

- (LYRTAccounts) getAllAccounts
{
  [self send_getAllAccounts];
  return [self recv_getAllAccounts];
}

- (void) send_getAccountWithApps: (LYRTUUID) id
{
  [outProtocol writeMessageBeginWithName: @"getAccountWithApps" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getAccountWithApps_args"];
  if (id != nil)  {
    [outProtocol writeFieldBeginWithName: @"id" type: TType_STRING fieldID: 1];
    [outProtocol writeBinary: id];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (LYRTAccountApps *) recv_getAccountWithApps
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  LYRTGetAccountWithApps_result * result = [[[LYRTGetAccountWithApps_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result nfExceptionIsSet]) {
    @throw [result nfException];
  }
  if ([result intExceptionIsSet]) {
    @throw [result intException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getAccountWithApps failed: unknown result"];
}

- (LYRTAccountApps *) getAccountWithApps: (LYRTUUID) id
{
  [self send_getAccountWithApps : id];
  return [self recv_getAccountWithApps];
}

- (void) send_getAccountsWithApps
{
  [outProtocol writeMessageBeginWithName: @"getAccountsWithApps" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getAccountsWithApps_args"];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (LYRTAccountsWithApps) recv_getAccountsWithApps
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  LYRTGetAccountsWithApps_result * result = [[[LYRTGetAccountsWithApps_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result nfExceptionIsSet]) {
    @throw [result nfException];
  }
  if ([result intExceptionIsSet]) {
    @throw [result intException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getAccountsWithApps failed: unknown result"];
}

- (LYRTAccountsWithApps) getAccountsWithApps
{
  [self send_getAccountsWithApps];
  return [self recv_getAccountsWithApps];
}

- (void) send_setApnsCertificate: (LYRTUUID) app_id p12_archive: (NSData *) p12_archive password: (NSString *) password is_sandbox: (BOOL) is_sandbox
{
  [outProtocol writeMessageBeginWithName: @"setApnsCertificate" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"setApnsCertificate_args"];
  if (app_id != nil)  {
    [outProtocol writeFieldBeginWithName: @"app_id" type: TType_STRING fieldID: 1];
    [outProtocol writeBinary: app_id];
    [outProtocol writeFieldEnd];
  }
  if (p12_archive != nil)  {
    [outProtocol writeFieldBeginWithName: @"p12_archive" type: TType_STRING fieldID: 2];
    [outProtocol writeBinary: p12_archive];
    [outProtocol writeFieldEnd];
  }
  if (password != nil)  {
    [outProtocol writeFieldBeginWithName: @"password" type: TType_STRING fieldID: 3];
    [outProtocol writeString: password];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"is_sandbox" type: TType_BOOL fieldID: 4];
  [outProtocol writeBool: is_sandbox];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (void) recv_setApnsCertificate
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  LYRTSetApnsCertificate_result * result = [[[LYRTSetApnsCertificate_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result nfExceptionIsSet]) {
    @throw [result nfException];
  }
  if ([result intExceptionIsSet]) {
    @throw [result intException];
  }
  if ([result brExceptionIsSet]) {
    @throw [result brException];
  }
  return;
}

- (void) setApnsCertificate: (LYRTUUID) app_id p12_archive: (NSData *) p12_archive password: (NSString *) password is_sandbox: (BOOL) is_sandbox
{
  [self send_setApnsCertificate : app_id p12_archive: p12_archive password: password is_sandbox: is_sandbox];
  [self recv_setApnsCertificate];
}

- (void) send_getApp: (LYRTUUID) app_id
{
  [outProtocol writeMessageBeginWithName: @"getApp" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getApp_args"];
  if (app_id != nil)  {
    [outProtocol writeFieldBeginWithName: @"app_id" type: TType_STRING fieldID: 1];
    [outProtocol writeBinary: app_id];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (LYRTApp *) recv_getApp
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  LYRTGetApp_result * result = [[[LYRTGetApp_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result nfExceptionIsSet]) {
    @throw [result nfException];
  }
  if ([result intExceptionIsSet]) {
    @throw [result intException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getApp failed: unknown result"];
}

- (LYRTApp *) getApp: (LYRTUUID) app_id
{
  [self send_getApp : app_id];
  return [self recv_getApp];
}

- (void) send_updateApp: (LYRTApp *) app
{
  [outProtocol writeMessageBeginWithName: @"updateApp" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"updateApp_args"];
  if (app != nil)  {
    [outProtocol writeFieldBeginWithName: @"app" type: TType_STRUCT fieldID: 1];
    [app write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (void) recv_updateApp
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  LYRTUpdateApp_result * result = [[[LYRTUpdateApp_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result nfExceptionIsSet]) {
    @throw [result nfException];
  }
  if ([result intExceptionIsSet]) {
    @throw [result intException];
  }
  return;
}

- (void) updateApp: (LYRTApp *) app
{
  [self send_updateApp : app];
  [self recv_updateApp];
}

- (void) send_createApp: (LYRTUUID) account_id app: (LYRTApp *) app
{
  [outProtocol writeMessageBeginWithName: @"createApp" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"createApp_args"];
  if (account_id != nil)  {
    [outProtocol writeFieldBeginWithName: @"account_id" type: TType_STRING fieldID: 1];
    [outProtocol writeBinary: account_id];
    [outProtocol writeFieldEnd];
  }
  if (app != nil)  {
    [outProtocol writeFieldBeginWithName: @"app" type: TType_STRUCT fieldID: 2];
    [app write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (LYRTApp *) recv_createApp
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  LYRTCreateApp_result * result = [[[LYRTCreateApp_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result intExceptionIsSet]) {
    @throw [result intException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"createApp failed: unknown result"];
}

- (LYRTApp *) createApp: (LYRTUUID) account_id app: (LYRTApp *) app
{
  [self send_createApp : account_id app: app];
  return [self recv_createApp];
}

- (void) send_getAppsFromAccount: (LYRTUUID) account_id
{
  [outProtocol writeMessageBeginWithName: @"getAppsFromAccount" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getAppsFromAccount_args"];
  if (account_id != nil)  {
    [outProtocol writeFieldBeginWithName: @"account_id" type: TType_STRING fieldID: 1];
    [outProtocol writeBinary: account_id];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (LYRTApps) recv_getAppsFromAccount
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  LYRTGetAppsFromAccount_result * result = [[[LYRTGetAppsFromAccount_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result nfExceptionIsSet]) {
    @throw [result nfException];
  }
  if ([result intExceptionIsSet]) {
    @throw [result intException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getAppsFromAccount failed: unknown result"];
}

- (LYRTApps) getAppsFromAccount: (LYRTUUID) account_id
{
  [self send_getAppsFromAccount : account_id];
  return [self recv_getAppsFromAccount];
}

- (void) send_addPublicKey: (LYRTPublicKey *) public_key
{
  [outProtocol writeMessageBeginWithName: @"addPublicKey" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"addPublicKey_args"];
  if (public_key != nil)  {
    [outProtocol writeFieldBeginWithName: @"public_key" type: TType_STRUCT fieldID: 1];
    [public_key write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (LYRTPublicKey *) recv_addPublicKey
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  LYRTAddPublicKey_result * result = [[[LYRTAddPublicKey_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result intExceptionIsSet]) {
    @throw [result intException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"addPublicKey failed: unknown result"];
}

- (LYRTPublicKey *) addPublicKey: (LYRTPublicKey *) public_key
{
  [self send_addPublicKey : public_key];
  return [self recv_addPublicKey];
}

- (void) send_getPublicKey: (LYRTUUID) provider_id key_id: (LYRTUUID) key_id
{
  [outProtocol writeMessageBeginWithName: @"getPublicKey" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getPublicKey_args"];
  if (provider_id != nil)  {
    [outProtocol writeFieldBeginWithName: @"provider_id" type: TType_STRING fieldID: 1];
    [outProtocol writeBinary: provider_id];
    [outProtocol writeFieldEnd];
  }
  if (key_id != nil)  {
    [outProtocol writeFieldBeginWithName: @"key_id" type: TType_STRING fieldID: 2];
    [outProtocol writeBinary: key_id];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (LYRTPublicKey *) recv_getPublicKey
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  LYRTGetPublicKey_result * result = [[[LYRTGetPublicKey_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result nfExceptionIsSet]) {
    @throw [result nfException];
  }
  if ([result intExceptionIsSet]) {
    @throw [result intException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getPublicKey failed: unknown result"];
}

- (LYRTPublicKey *) getPublicKey: (LYRTUUID) provider_id key_id: (LYRTUUID) key_id
{
  [self send_getPublicKey : provider_id key_id: key_id];
  return [self recv_getPublicKey];
}

- (void) send_getAllPublicKeys: (LYRTUUID) provider_id
{
  [outProtocol writeMessageBeginWithName: @"getAllPublicKeys" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getAllPublicKeys_args"];
  if (provider_id != nil)  {
    [outProtocol writeFieldBeginWithName: @"provider_id" type: TType_STRING fieldID: 1];
    [outProtocol writeBinary: provider_id];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSMutableArray *) recv_getAllPublicKeys
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  LYRTGetAllPublicKeys_result * result = [[[LYRTGetAllPublicKeys_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result nfExceptionIsSet]) {
    @throw [result nfException];
  }
  if ([result intExceptionIsSet]) {
    @throw [result intException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getAllPublicKeys failed: unknown result"];
}

- (NSMutableArray *) getAllPublicKeys: (LYRTUUID) provider_id
{
  [self send_getAllPublicKeys : provider_id];
  return [self recv_getAllPublicKeys];
}

- (void) send_updatePublicKey: (LYRTPublicKey *) public_key
{
  [outProtocol writeMessageBeginWithName: @"updatePublicKey" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"updatePublicKey_args"];
  if (public_key != nil)  {
    [outProtocol writeFieldBeginWithName: @"public_key" type: TType_STRUCT fieldID: 1];
    [public_key write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (void) recv_updatePublicKey
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  LYRTUpdatePublicKey_result * result = [[[LYRTUpdatePublicKey_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result nfExceptionIsSet]) {
    @throw [result nfException];
  }
  if ([result intExceptionIsSet]) {
    @throw [result intException];
  }
  return;
}

- (void) updatePublicKey: (LYRTPublicKey *) public_key
{
  [self send_updatePublicKey : public_key];
  [self recv_updatePublicKey];
}

- (void) send_toggleUserBlacklist: (LYRTUUID) app_id user_id: (LYRTUUID) user_id blacklisted: (BOOL) blacklisted
{
  [outProtocol writeMessageBeginWithName: @"toggleUserBlacklist" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"toggleUserBlacklist_args"];
  if (app_id != nil)  {
    [outProtocol writeFieldBeginWithName: @"app_id" type: TType_STRING fieldID: 1];
    [outProtocol writeBinary: app_id];
    [outProtocol writeFieldEnd];
  }
  if (user_id != nil)  {
    [outProtocol writeFieldBeginWithName: @"user_id" type: TType_STRING fieldID: 2];
    [outProtocol writeBinary: user_id];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"blacklisted" type: TType_BOOL fieldID: 3];
  [outProtocol writeBool: blacklisted];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (BOOL) recv_toggleUserBlacklist
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  LYRTToggleUserBlacklist_result * result = [[[LYRTToggleUserBlacklist_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result nfExceptionIsSet]) {
    @throw [result nfException];
  }
  if ([result intExceptionIsSet]) {
    @throw [result intException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"toggleUserBlacklist failed: unknown result"];
}

- (BOOL) toggleUserBlacklist: (LYRTUUID) app_id user_id: (LYRTUUID) user_id blacklisted: (BOOL) blacklisted
{
  [self send_toggleUserBlacklist : app_id user_id: user_id blacklisted: blacklisted];
  return [self recv_toggleUserBlacklist];
}

- (void) send_revokeSession: (LYRTUUID) app_id user_id: (LYRTUUID) user_id
{
  [outProtocol writeMessageBeginWithName: @"revokeSession" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"revokeSession_args"];
  if (app_id != nil)  {
    [outProtocol writeFieldBeginWithName: @"app_id" type: TType_STRING fieldID: 1];
    [outProtocol writeBinary: app_id];
    [outProtocol writeFieldEnd];
  }
  if (user_id != nil)  {
    [outProtocol writeFieldBeginWithName: @"user_id" type: TType_STRING fieldID: 2];
    [outProtocol writeBinary: user_id];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (void) recv_revokeSession
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  LYRTRevokeSession_result * result = [[[LYRTRevokeSession_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result nfExceptionIsSet]) {
    @throw [result nfException];
  }
  if ([result intExceptionIsSet]) {
    @throw [result intException];
  }
  return;
}

- (void) revokeSession: (LYRTUUID) app_id user_id: (LYRTUUID) user_id
{
  [self send_revokeSession : app_id user_id: user_id];
  [self recv_revokeSession];
}

- (void) send_ping: (NSString *) ping
{
  [outProtocol writeMessageBeginWithName: @"ping" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"ping_args"];
  if (ping != nil)  {
    [outProtocol writeFieldBeginWithName: @"ping" type: TType_STRING fieldID: 1];
    [outProtocol writeString: ping];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_ping
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  LYRTPing_result * result = [[[LYRTPing_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"ping failed: unknown result"];
}

- (NSString *) ping: (NSString *) ping
{
  [self send_ping : ping];
  return [self recv_ping];
}

@end

@implementation LYRTCtrlProcessor

- (id) initWithCtrl: (id <LYRTCtrl>) service
{
  self = [super init];
  if (!self) {
    return nil;
  }
  mService = [service retain_stub];
  mMethodMap = [[NSMutableDictionary dictionary] retain_stub];
  {
    SEL s = @selector(process_createAccount_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"createAccount"];
  }
  {
    SEL s = @selector(process_getAccount_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getAccount"];
  }
  {
    SEL s = @selector(process_updateAccount_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"updateAccount"];
  }
  {
    SEL s = @selector(process_login_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"login"];
  }
  {
    SEL s = @selector(process_resetPassword_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"resetPassword"];
  }
  {
    SEL s = @selector(process_forceResetPassword_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"forceResetPassword"];
  }
  {
    SEL s = @selector(process_getAccountByEmail_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getAccountByEmail"];
  }
  {
    SEL s = @selector(process_getAllAccounts_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getAllAccounts"];
  }
  {
    SEL s = @selector(process_getAccountWithApps_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getAccountWithApps"];
  }
  {
    SEL s = @selector(process_getAccountsWithApps_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getAccountsWithApps"];
  }
  {
    SEL s = @selector(process_setApnsCertificate_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"setApnsCertificate"];
  }
  {
    SEL s = @selector(process_getApp_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getApp"];
  }
  {
    SEL s = @selector(process_updateApp_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"updateApp"];
  }
  {
    SEL s = @selector(process_createApp_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"createApp"];
  }
  {
    SEL s = @selector(process_getAppsFromAccount_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getAppsFromAccount"];
  }
  {
    SEL s = @selector(process_addPublicKey_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"addPublicKey"];
  }
  {
    SEL s = @selector(process_getPublicKey_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getPublicKey"];
  }
  {
    SEL s = @selector(process_getAllPublicKeys_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getAllPublicKeys"];
  }
  {
    SEL s = @selector(process_updatePublicKey_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"updatePublicKey"];
  }
  {
    SEL s = @selector(process_toggleUserBlacklist_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"toggleUserBlacklist"];
  }
  {
    SEL s = @selector(process_revokeSession_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"revokeSession"];
  }
  {
    SEL s = @selector(process_ping_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"ping"];
  }
  return self;
}

- (id<LYRTCtrl>) service
{
  return [[mService retain_stub] autorelease_stub];
}

- (BOOL) processOnInputProtocol: (id <TProtocol>) inProtocol
                 outputProtocol: (id <TProtocol>) outProtocol
{
  NSString * messageName;
  int messageType;
  int seqID;
  [inProtocol readMessageBeginReturningName: &messageName
                                       type: &messageType
                                 sequenceID: &seqID];
  NSInvocation * invocation = [mMethodMap valueForKey: messageName];
  if (invocation == nil) {
    [TProtocolUtil skipType: TType_STRUCT onProtocol: inProtocol];
    [inProtocol readMessageEnd];
    TApplicationException * x = [TApplicationException exceptionWithType: TApplicationException_UNKNOWN_METHOD reason: [NSString stringWithFormat: @"Invalid method name: '%@'", messageName]];
    [outProtocol writeMessageBeginWithName: messageName
                                      type: TMessageType_EXCEPTION
                                sequenceID: seqID];
    [x write: outProtocol];
    [outProtocol writeMessageEnd];
    [[outProtocol transport] flush];
    return YES;
  }
  // NSInvocation does not conform to NSCopying protocol
  NSInvocation * i = [NSInvocation invocationWithMethodSignature: [invocation methodSignature]];
  [i setSelector: [invocation selector]];
  [i setArgument: &seqID atIndex: 2];
  [i setArgument: &inProtocol atIndex: 3];
  [i setArgument: &outProtocol atIndex: 4];
  [i setTarget: self];
  [i invoke];
  return YES;
}

- (void) process_createAccount_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  LYRTcreateAccount_args * args = [[LYRTcreateAccount_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  LYRTCreateAccount_result * result = [[LYRTCreateAccount_result alloc] init];
  [result setSuccess: [mService createAccount: [args account]]];
  [outProtocol writeMessageBeginWithName: @"createAccount"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getAccount_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  LYRTgetAccount_args * args = [[LYRTgetAccount_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  LYRTGetAccount_result * result = [[LYRTGetAccount_result alloc] init];
  [result setSuccess: [mService getAccount: [args id]]];
  [outProtocol writeMessageBeginWithName: @"getAccount"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_updateAccount_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  LYRTupdateAccount_args * args = [[LYRTupdateAccount_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  LYRTUpdateAccount_result * result = [[LYRTUpdateAccount_result alloc] init];
  [mService updateAccount: [args account]];
  [outProtocol writeMessageBeginWithName: @"updateAccount"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_login_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  LYRTlogin_args * args = [[LYRTlogin_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  LYRTLogin_result * result = [[LYRTLogin_result alloc] init];
  [result setSuccess: [mService login: [args email] password: [args password]]];
  [outProtocol writeMessageBeginWithName: @"login"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_resetPassword_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  LYRTresetPassword_args * args = [[LYRTresetPassword_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  LYRTResetPassword_result * result = [[LYRTResetPassword_result alloc] init];
  [mService resetPassword: [args id] old_password: [args old_password] new_password: [args new_password]];
  [outProtocol writeMessageBeginWithName: @"resetPassword"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_forceResetPassword_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  LYRTforceResetPassword_args * args = [[LYRTforceResetPassword_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  LYRTForceResetPassword_result * result = [[LYRTForceResetPassword_result alloc] init];
  [mService forceResetPassword: [args id] new_password: [args new_password]];
  [outProtocol writeMessageBeginWithName: @"forceResetPassword"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getAccountByEmail_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  LYRTgetAccountByEmail_args * args = [[LYRTgetAccountByEmail_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  LYRTGetAccountByEmail_result * result = [[LYRTGetAccountByEmail_result alloc] init];
  [result setSuccess: [mService getAccountByEmail: [args email]]];
  [outProtocol writeMessageBeginWithName: @"getAccountByEmail"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getAllAccounts_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  LYRTgetAllAccounts_args * args = [[LYRTgetAllAccounts_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  LYRTGetAllAccounts_result * result = [[LYRTGetAllAccounts_result alloc] init];
  [result setSuccess: [mService getAllAccounts]];
  [outProtocol writeMessageBeginWithName: @"getAllAccounts"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getAccountWithApps_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  LYRTgetAccountWithApps_args * args = [[LYRTgetAccountWithApps_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  LYRTGetAccountWithApps_result * result = [[LYRTGetAccountWithApps_result alloc] init];
  [result setSuccess: [mService getAccountWithApps: [args id]]];
  [outProtocol writeMessageBeginWithName: @"getAccountWithApps"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getAccountsWithApps_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  LYRTgetAccountsWithApps_args * args = [[LYRTgetAccountsWithApps_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  LYRTGetAccountsWithApps_result * result = [[LYRTGetAccountsWithApps_result alloc] init];
  [result setSuccess: [mService getAccountsWithApps]];
  [outProtocol writeMessageBeginWithName: @"getAccountsWithApps"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_setApnsCertificate_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  LYRTsetApnsCertificate_args * args = [[LYRTsetApnsCertificate_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  LYRTSetApnsCertificate_result * result = [[LYRTSetApnsCertificate_result alloc] init];
  [mService setApnsCertificate: [args app_id] p12_archive: [args p12_archive] password: [args password] is_sandbox: [args is_sandbox]];
  [outProtocol writeMessageBeginWithName: @"setApnsCertificate"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getApp_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  LYRTgetApp_args * args = [[LYRTgetApp_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  LYRTGetApp_result * result = [[LYRTGetApp_result alloc] init];
  [result setSuccess: [mService getApp: [args app_id]]];
  [outProtocol writeMessageBeginWithName: @"getApp"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_updateApp_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  LYRTupdateApp_args * args = [[LYRTupdateApp_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  LYRTUpdateApp_result * result = [[LYRTUpdateApp_result alloc] init];
  [mService updateApp: [args app]];
  [outProtocol writeMessageBeginWithName: @"updateApp"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_createApp_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  LYRTcreateApp_args * args = [[LYRTcreateApp_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  LYRTCreateApp_result * result = [[LYRTCreateApp_result alloc] init];
  [result setSuccess: [mService createApp: [args account_id] app: [args app]]];
  [outProtocol writeMessageBeginWithName: @"createApp"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getAppsFromAccount_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  LYRTgetAppsFromAccount_args * args = [[LYRTgetAppsFromAccount_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  LYRTGetAppsFromAccount_result * result = [[LYRTGetAppsFromAccount_result alloc] init];
  [result setSuccess: [mService getAppsFromAccount: [args account_id]]];
  [outProtocol writeMessageBeginWithName: @"getAppsFromAccount"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_addPublicKey_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  LYRTaddPublicKey_args * args = [[LYRTaddPublicKey_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  LYRTAddPublicKey_result * result = [[LYRTAddPublicKey_result alloc] init];
  [result setSuccess: [mService addPublicKey: [args public_key]]];
  [outProtocol writeMessageBeginWithName: @"addPublicKey"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getPublicKey_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  LYRTgetPublicKey_args * args = [[LYRTgetPublicKey_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  LYRTGetPublicKey_result * result = [[LYRTGetPublicKey_result alloc] init];
  [result setSuccess: [mService getPublicKey: [args provider_id] key_id: [args key_id]]];
  [outProtocol writeMessageBeginWithName: @"getPublicKey"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getAllPublicKeys_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  LYRTgetAllPublicKeys_args * args = [[LYRTgetAllPublicKeys_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  LYRTGetAllPublicKeys_result * result = [[LYRTGetAllPublicKeys_result alloc] init];
  [result setSuccess: [mService getAllPublicKeys: [args provider_id]]];
  [outProtocol writeMessageBeginWithName: @"getAllPublicKeys"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_updatePublicKey_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  LYRTupdatePublicKey_args * args = [[LYRTupdatePublicKey_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  LYRTUpdatePublicKey_result * result = [[LYRTUpdatePublicKey_result alloc] init];
  [mService updatePublicKey: [args public_key]];
  [outProtocol writeMessageBeginWithName: @"updatePublicKey"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_toggleUserBlacklist_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  LYRTtoggleUserBlacklist_args * args = [[LYRTtoggleUserBlacklist_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  LYRTToggleUserBlacklist_result * result = [[LYRTToggleUserBlacklist_result alloc] init];
  [result setSuccess: [mService toggleUserBlacklist: [args app_id] user_id: [args user_id] blacklisted: [args blacklisted]]];
  [outProtocol writeMessageBeginWithName: @"toggleUserBlacklist"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_revokeSession_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  LYRTrevokeSession_args * args = [[LYRTrevokeSession_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  LYRTRevokeSession_result * result = [[LYRTRevokeSession_result alloc] init];
  [mService revokeSession: [args app_id] user_id: [args user_id]];
  [outProtocol writeMessageBeginWithName: @"revokeSession"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_ping_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  LYRTping_args * args = [[LYRTping_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  LYRTPing_result * result = [[LYRTPing_result alloc] init];
  [result setSuccess: [mService ping: [args ping]]];
  [outProtocol writeMessageBeginWithName: @"ping"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) dealloc
{
  [mService release_stub];
  [mMethodMap release_stub];
  [super dealloc_stub];
}

@end

